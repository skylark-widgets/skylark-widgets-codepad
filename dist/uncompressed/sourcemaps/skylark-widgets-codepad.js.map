{"version":3,"sources":["skylark-widgets-codepad.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-widgets-codepad.js","sourcesContent":["define('skylark-widgets-codepad/util',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-net-http/Xhr\"\r\n],function (langx,Xhr) {\r\n    'use strict';\r\n\r\n    function fetch(url, callback) {\r\n        /*\r\n        var xhr = new window.XMLHttpRequest();\r\n        xhr.open('GET', url);\r\n        xhr.responseType = 'text';\r\n        xhr.onload = function () {\r\n            if (xhr.status === 200) {\r\n                callback(null, xhr.responseText);\r\n            } else {\r\n                callback(url, xhr);\r\n            }\r\n        };\r\n        xhr.onerror = function (err) {\r\n            callback(err);\r\n        };\r\n        xhr.send();\r\n        */\r\n        Xhr.get(url).then(\r\n            function(res) {\r\n                callback(null,res);\r\n            },\r\n            function(e){\r\n                callback(e);\r\n            }\r\n        )\r\n    }\r\n    function runCallback(index, params, arr, errors, callback) {\r\n        return function (err, res) {\r\n            if (err) {\r\n                errors.push(err);\r\n            }\r\n            index++;\r\n            if (index < arr.length) {\r\n                seqRunner(index, res, arr, errors, callback);\r\n            } else {\r\n                callback(errors, res);\r\n            }\r\n        };\r\n    }\r\n    function seqRunner(index, params, arr, errors, callback) {\r\n        arr[index](params, runCallback.apply(this, arguments));\r\n    }\r\n    function seq(arr, params, callback = function () {\r\n    }) {\r\n        var errors = [];\r\n        if (!arr.length) {\r\n            return callback(errors, params);\r\n        }\r\n        seqRunner(0, params, arr, errors, callback);\r\n    }\r\n    function log() {\r\n        console.log(arguments);\r\n    }\r\n\r\n\r\n    var defaultModemap = {\r\n        'html': 'html',\r\n        'css': 'css',\r\n        'js': 'javascript',\r\n        'less': 'less',\r\n        'styl': 'stylus',\r\n        'coffee': 'coffeescript'\r\n    };\r\n    function getMode(type = '', file = '', customModemap = {}) {\r\n        var modemap = langx.mixin({}, defaultModemap,customModemap);\r\n        for (let key in modemap) {\r\n            let keyLength = key.length;\r\n            if (file.slice(-keyLength++) === '.' + key) {\r\n                return modemap[key];\r\n            }\r\n        }\r\n        for (let key in modemap) {\r\n            if (type === key) {\r\n                return modemap[key];\r\n            }\r\n        }\r\n        return type;\r\n    }\r\n    return {\r\n        fetch,\r\n        seq,\r\n        log,\r\n        getMode\r\n    };\r\n});\ndefine('skylark-widgets-codepad/template',[],function () {\r\n    'use strict';\r\n    function container() {\r\n        return `\r\n    <ul class=\"codepad-nav\">\r\n      <li class=\"codepad-nav-item codepad-nav-item-result\">\r\n        <a href=\"#\" data-codepad-type=\"result\">\r\n          Result\r\n        </a>\r\n      </li>\r\n      <li class=\"codepad-nav-item codepad-nav-item-html\">\r\n        <a href=\"#\" data-codepad-type=\"html\">\r\n          HTML\r\n        </a>\r\n      </li>\r\n      <li class=\"codepad-nav-item codepad-nav-item-css\">\r\n        <a href=\"#\" data-codepad-type=\"css\">\r\n          CSS\r\n        </a>\r\n      </li>\r\n      <li class=\"codepad-nav-item codepad-nav-item-js\">\r\n        <a href=\"#\" data-codepad-type=\"js\">\r\n          JavaScript\r\n        </a>\r\n      </li>\r\n    </ul>\r\n    <div class=\"codepad-pane codepad-pane-result\"><iframe></iframe></div>\r\n    <div class=\"codepad-pane codepad-pane-html\"></div>\r\n    <div class=\"codepad-pane codepad-pane-css\"></div>\r\n    <div class=\"codepad-pane codepad-pane-js\"></div>\r\n  `;\r\n    }\r\n    function paneActiveClass(type) {\r\n        return `codepad-pane-active-${ type }`;\r\n    }\r\n    function containerClass() {\r\n        return 'codepad';\r\n    }\r\n    function hasFileClass(type) {\r\n        return `codepad-has-${ type }`;\r\n    }\r\n    function editorClass(type) {\r\n        return `codepad-editor codepad-editor-${ type }`;\r\n    }\r\n    function editorContent(type) {\r\n        return `\r\n    <textarea data-codepad-type=\"${ type }\" ></textarea>\r\n    <div class=\"codepad-status\"></div>\r\n  `;\r\n    }\r\n    function statusMessage(err) {\r\n        return `\r\n    <p>${ err }</p>\r\n  `;\r\n    }\r\n    function statusClass(type) {\r\n        return `codepad-status-${ type }`;\r\n    }\r\n    function statusActiveClass(type) {\r\n        return `codepad-status-active-${ type }`;\r\n    }\r\n    function pluginClass(name) {\r\n        return `codepad-plugin-${ name }`;\r\n    }\r\n    function statusLoading(url) {\r\n        return `Loading <strong>${ url }</strong>..`;\r\n    }\r\n    function statusFetchError(url) {\r\n        return `There was an error loading <strong>${ url }</strong>.`;\r\n    }\r\n    return {\r\n        container: container,\r\n        paneActiveClass: paneActiveClass,\r\n        containerClass: containerClass,\r\n        hasFileClass: hasFileClass,\r\n        editorClass: editorClass,\r\n        editorContent: editorContent,\r\n        statusMessage: statusMessage,\r\n        statusClass: statusClass,\r\n        statusActiveClass: statusActiveClass,\r\n        pluginClass: pluginClass,\r\n        statusLoading: statusLoading,\r\n        statusFetchError: statusFetchError\r\n    };\r\n});\ndefine('skylark-widgets-codepad/addons',[],function(){\r\n\treturn {\r\n\t    general : {\r\n\r\n\t    },\r\n\r\n\t    html : {\r\n      \r\n\t    },\r\n\r\n\t    css : {\r\n      \r\n\t    },\r\n\r\n\t    js : {\r\n      \r\n\t    },\r\n\r\n\t    edit : {\r\n      \r\n\t    }\t\r\n\t};\r\n});\ndefine('skylark-widgets-codepad/codepad',[\r\n    'skylark-langx/skylark',\r\n    'skylark-langx/langx',\r\n    'skylark-widgets-base/widget',\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-noder\",\r\n    './util',\r\n    './template',\r\n    \"./addons\"\r\n], function (skylark,langx,Widget, styler,datax,noder,util, template,addons) {\r\n    'use strict';\r\n\r\n    class Codepad extends Widget{\r\n        get klassName() {\r\n          return \"Codepad\";\r\n        } \r\n\r\n        get pluginName(){\r\n          return \"lark.Codepad\";\r\n        } \r\n\r\n        //default options\r\n        get options () {\r\n            return {\r\n                files: [],\r\n                showBlank: false,\r\n                runScripts: true,\r\n                pane: 'result',\r\n                debounce: 250,\r\n                addons: {\r\n                    \"general\" : [\"render\"]\r\n                }\r\n            }\r\n        }\r\n\r\n        _init () {\r\n  \r\n            var options = this.options;\r\n            if (options.runScripts === false) {\r\n                options.addons.gerneral.push('scriptless');\r\n            }\r\n\r\n            super._init();\r\n\r\n            this._cached =  {\r\n                html: null,\r\n                css: null,\r\n                js: null\r\n            };\r\n\r\n            var $container = this.$container = this._elm;\r\n\r\n            var paneActive = this._paneActive = options.pane;\r\n\r\n            var velm = this._velm;\r\n            velm.html(template.container())\r\n                .addClass(template.containerClass())\r\n                .addClass(template.paneActiveClass(paneActive))\r\n                ///.on('keyup', langx.debounce(this.change.bind(this), options.debounce))\r\n                .on('change', langx.debounce(this.change.bind(this), options.debounce))\r\n                .on('click', this.pane.bind(this));\r\n\r\n            this._$status =  {};\r\n\r\n            for (let type of [\r\n                    'html',\r\n                    'css',\r\n                    'js'\r\n                ]) {\r\n                if (this.options.codes[type] !== false) {\r\n                    this._markup(type);\r\n                }\r\n            }\r\n            this._setCodes(this.options.codes);\r\n        }\r\n\r\n        _startup() {\r\n            var options = this.options;\r\n            this.paneActive = this._paneActive;\r\n\r\n            if (options.showBlank) {\r\n                for (let type of [\r\n                        'html',\r\n                        'css',\r\n                        'js'\r\n                    ]) {\r\n                    this._velm.addClass(template.hasFileClass(type));\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        _markup(type) {\r\n            var $container = this._elm;\r\n            var $parent = this.$().find(`.codepad-pane-${ type }`);\r\n\r\n            $parent.append(noder.createElement(\"div\",{\r\n                innerHTML : template.editorContent(type),\r\n                className : template.editorClass(type)\r\n            }));\r\n            this._$status[type] = $parent.find('.codepad-status');\r\n             styler.addClass($container, template.hasFileClass(type));\r\n        }\r\n\r\n        _load(type) {\r\n            var cached = this._cached,\r\n                code = cached[type] || {},\r\n                content;\r\n\r\n            if (langx.isString(code)) {\r\n                content = code;\r\n            } else {\r\n                content = code.content || \"\";\r\n            }\r\n            var $textarea = this.$(`.codepad-pane-${ type } textarea`);\r\n            $textarea.val(content);\r\n        }\r\n\r\n\r\n        change(e) {\r\n            var type = datax.data(e.target, 'codepad-type');\r\n            if (!type) {\r\n                return;\r\n            }\r\n            var cached = this._cached;\r\n            if (cached[type] === e.target.value) {\r\n                return;\r\n            }\r\n            cached[type] = e.target.value;\r\n            this.emit('changed', {\r\n                type: type,\r\n                file: datax.data(e.target, 'codepad-file'),\r\n                content: cached[type]\r\n            });\r\n        }\r\n\r\n        getCodes() {\r\n            return langx.clone(this._cached);\r\n        }\r\n\r\n        _setCodes(codes) {\r\n            var cached = this._cached;\r\n            cached.html = codes.html || null;\r\n            cached.css = codes.css || null;\r\n            cached.js = codes.js || null;\r\n\r\n            for (let type of [\r\n                    'html',\r\n                    'css',\r\n                    'js'\r\n                ]) {\r\n                this._load(type);\r\n            }\r\n        }\r\n\r\n        resetCodes(codes) {\r\n            this._setCodes(codes);\r\n            this.emit(\"reseted\");\r\n            return this;\r\n        }\r\n\r\n        errors(errs, params) {\r\n            this.status('error', errs, params);\r\n        }\r\n\r\n        pane(e) {\r\n            if (!datax.data(e.target, 'codepad-type')) {\r\n                return;\r\n            }\r\n           let oldPaneActive = this._paneActive,\r\n                paneActive = this._paneActive = datax.data(e.target, 'codepad-type');\r\n            this.elmx().removeClass(template.paneActiveClass(oldPaneActive))\r\n                       .addClass(template.paneActiveClass(paneActive));\r\n            e.preventDefault();\r\n        }\r\n\r\n        status(statusType = 'error', messages = [], params = {}) {\r\n            if (!messages.length) {\r\n                return this.clearStatus(statusType, params);\r\n            }\r\n            var $status = this._get('$status');\r\n            styler.addClass($status[params.type], template.statusClass(statusType));\r\n            //styler.addClass(this._get('$container'), template.statusActiveClass(params.type));\r\n            styler.addClass(this._elm, template.statusActiveClass(params.type));\r\n            var markup = '';\r\n            messages.forEach(function (err) {\r\n                markup += template.statusMessage(err);\r\n            });\r\n            $status[params.type].innerHTML = markup;\r\n        }\r\n        clearStatus(statusType, params) {\r\n            var $status = this._get('$status');\r\n            styler.removeClass($status[params.type], template.statusClass(statusType));\r\n            //styler.removeClass(this._get('$container'), template.statusActiveClass(params.type));\r\n            styler.removeClass(this._elm, template.statusActiveClass(params.type));\r\n            $status[params.type].innerHTML = '';\r\n        }\r\n    }\r\n    Codepad.addons = addons;\r\n\r\n    return skylark.attach(\"widgets.Codepad\",Codepad);\r\n});\ndefine('skylark-widgets-base/addon',[\r\n  \"skylark-langx-objects\",\t\r\n  \"skylark-langx/Evented\",\r\n\t\"./base\"\r\n],function(objects,Evented,base){\r\n\r\n\tvar Addon = Evented.inherit({\r\n\r\n\t\t_construct : function(widget,options) {\r\n\t\t\tthis._widget = widget;\r\n            Object.defineProperty(this,\"options\",{\r\n              value :objects.mixin({},this.options,options,true)\r\n            });\r\n\t\t\tif (this._init) {\r\n\t\t\t\tthis._init();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tAddon.register = function(Widget) {\r\n\t\tvar categoryName = this.categoryName,\r\n\t\t\taddonName = this.addonName;\r\n\r\n\t\tif (categoryName && addonName) {\r\n\t\t\tWidget.addons = Widget.addons || {};\r\n\t\t\tWidget.addons[categoryName] = Widget.addons[categoryName] || {};\r\n\t\t\tWidget.addons[categoryName][addonName] = this;\r\n\t\t}\r\n\t};\r\n\r\n\treturn base.Addon = Addon;\r\n\r\n});\ndefine('skylark-widgets-codepad/addon',[\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-widgets-base/addon\"\r\n],function(styler,_Addon){\r\n\treturn class Addon extends _Addon {\r\n\t\t_init() {\r\n            this.coder = this._widget;\r\n\r\n            this.options.pluginCssClass = this.options.pluginClass || (\"codepad-plugin-\" + this.constructor.addonName);\r\n\r\n\t\t\tif (this.options.pluginCssClass) {\r\n\t            styler.addClass(this._widget._elm, this.options.pluginCssClass);\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n});\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/mode/xml/xml',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nvar htmlConfig = {\r\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\r\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\r\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\r\n                    'track': true, 'wbr': true, 'menuitem': true},\r\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\r\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\r\n                     'th': true, 'tr': true},\r\n  contextGrabbers: {\r\n    'dd': {'dd': true, 'dt': true},\r\n    'dt': {'dd': true, 'dt': true},\r\n    'li': {'li': true},\r\n    'option': {'option': true, 'optgroup': true},\r\n    'optgroup': {'optgroup': true},\r\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\r\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\r\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\r\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\r\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\r\n    'rp': {'rp': true, 'rt': true},\r\n    'rt': {'rp': true, 'rt': true},\r\n    'tbody': {'tbody': true, 'tfoot': true},\r\n    'td': {'td': true, 'th': true},\r\n    'tfoot': {'tbody': true},\r\n    'th': {'td': true, 'th': true},\r\n    'thead': {'tbody': true, 'tfoot': true},\r\n    'tr': {'tr': true}\r\n  },\r\n  doNotIndent: {\"pre\": true},\r\n  allowUnquoted: true,\r\n  allowMissing: true,\r\n  caseFold: true\r\n}\r\n\r\nvar xmlConfig = {\r\n  autoSelfClosers: {},\r\n  implicitlyClosed: {},\r\n  contextGrabbers: {},\r\n  doNotIndent: {},\r\n  allowUnquoted: false,\r\n  allowMissing: false,\r\n  allowMissingTagName: false,\r\n  caseFold: false\r\n}\r\n\r\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\r\n  var indentUnit = editorConf.indentUnit\r\n  var config = {}\r\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\r\n  for (var prop in defaults) config[prop] = defaults[prop]\r\n  for (var prop in config_) config[prop] = config_[prop]\r\n\r\n  // Return variables for tokenizers\r\n  var type, setStyle;\r\n\r\n  function inText(stream, state) {\r\n    function chain(parser) {\r\n      state.tokenize = parser;\r\n      return parser(stream, state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n    if (ch == \"<\") {\r\n      if (stream.eat(\"!\")) {\r\n        if (stream.eat(\"[\")) {\r\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\r\n          else return null;\r\n        } else if (stream.match(\"--\")) {\r\n          return chain(inBlock(\"comment\", \"-->\"));\r\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\r\n          stream.eatWhile(/[\\w\\._\\-]/);\r\n          return chain(doctype(1));\r\n        } else {\r\n          return null;\r\n        }\r\n      } else if (stream.eat(\"?\")) {\r\n        stream.eatWhile(/[\\w\\._\\-]/);\r\n        state.tokenize = inBlock(\"meta\", \"?>\");\r\n        return \"meta\";\r\n      } else {\r\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\r\n        state.tokenize = inTag;\r\n        return \"tag bracket\";\r\n      }\r\n    } else if (ch == \"&\") {\r\n      var ok;\r\n      if (stream.eat(\"#\")) {\r\n        if (stream.eat(\"x\")) {\r\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\r\n        } else {\r\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\r\n        }\r\n      } else {\r\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\r\n      }\r\n      return ok ? \"atom\" : \"error\";\r\n    } else {\r\n      stream.eatWhile(/[^&<]/);\r\n      return null;\r\n    }\r\n  }\r\n  inText.isInText = true;\r\n\r\n  function inTag(stream, state) {\r\n    var ch = stream.next();\r\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\r\n      state.tokenize = inText;\r\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\r\n      return \"tag bracket\";\r\n    } else if (ch == \"=\") {\r\n      type = \"equals\";\r\n      return null;\r\n    } else if (ch == \"<\") {\r\n      state.tokenize = inText;\r\n      state.state = baseState;\r\n      state.tagName = state.tagStart = null;\r\n      var next = state.tokenize(stream, state);\r\n      return next ? next + \" tag error\" : \"tag error\";\r\n    } else if (/[\\'\\\"]/.test(ch)) {\r\n      state.tokenize = inAttribute(ch);\r\n      state.stringStartCol = stream.column();\r\n      return state.tokenize(stream, state);\r\n    } else {\r\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\r\n      return \"word\";\r\n    }\r\n  }\r\n\r\n  function inAttribute(quote) {\r\n    var closure = function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.next() == quote) {\r\n          state.tokenize = inTag;\r\n          break;\r\n        }\r\n      }\r\n      return \"string\";\r\n    };\r\n    closure.isInAttribute = true;\r\n    return closure;\r\n  }\r\n\r\n  function inBlock(style, terminator) {\r\n    return function(stream, state) {\r\n      while (!stream.eol()) {\r\n        if (stream.match(terminator)) {\r\n          state.tokenize = inText;\r\n          break;\r\n        }\r\n        stream.next();\r\n      }\r\n      return style;\r\n    }\r\n  }\r\n\r\n  function doctype(depth) {\r\n    return function(stream, state) {\r\n      var ch;\r\n      while ((ch = stream.next()) != null) {\r\n        if (ch == \"<\") {\r\n          state.tokenize = doctype(depth + 1);\r\n          return state.tokenize(stream, state);\r\n        } else if (ch == \">\") {\r\n          if (depth == 1) {\r\n            state.tokenize = inText;\r\n            break;\r\n          } else {\r\n            state.tokenize = doctype(depth - 1);\r\n            return state.tokenize(stream, state);\r\n          }\r\n        }\r\n      }\r\n      return \"meta\";\r\n    };\r\n  }\r\n\r\n  function Context(state, tagName, startOfLine) {\r\n    this.prev = state.context;\r\n    this.tagName = tagName;\r\n    this.indent = state.indented;\r\n    this.startOfLine = startOfLine;\r\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\r\n      this.noIndent = true;\r\n  }\r\n  function popContext(state) {\r\n    if (state.context) state.context = state.context.prev;\r\n  }\r\n  function maybePopContext(state, nextTagName) {\r\n    var parentTagName;\r\n    while (true) {\r\n      if (!state.context) {\r\n        return;\r\n      }\r\n      parentTagName = state.context.tagName;\r\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\r\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\r\n        return;\r\n      }\r\n      popContext(state);\r\n    }\r\n  }\r\n\r\n  function baseState(type, stream, state) {\r\n    if (type == \"openTag\") {\r\n      state.tagStart = stream.column();\r\n      return tagNameState;\r\n    } else if (type == \"closeTag\") {\r\n      return closeTagNameState;\r\n    } else {\r\n      return baseState;\r\n    }\r\n  }\r\n  function tagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      state.tagName = stream.current();\r\n      setStyle = \"tag\";\r\n      return attrState;\r\n    } else if (config.allowMissingTagName && type == \"endTag\") {\r\n      setStyle = \"tag bracket\";\r\n      return attrState(type, stream, state);\r\n    } else {\r\n      setStyle = \"error\";\r\n      return tagNameState;\r\n    }\r\n  }\r\n  function closeTagNameState(type, stream, state) {\r\n    if (type == \"word\") {\r\n      var tagName = stream.current();\r\n      if (state.context && state.context.tagName != tagName &&\r\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\r\n        popContext(state);\r\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\r\n        setStyle = \"tag\";\r\n        return closeState;\r\n      } else {\r\n        setStyle = \"tag error\";\r\n        return closeStateErr;\r\n      }\r\n    } else if (config.allowMissingTagName && type == \"endTag\") {\r\n      setStyle = \"tag bracket\";\r\n      return closeState(type, stream, state);\r\n    } else {\r\n      setStyle = \"error\";\r\n      return closeStateErr;\r\n    }\r\n  }\r\n\r\n  function closeState(type, _stream, state) {\r\n    if (type != \"endTag\") {\r\n      setStyle = \"error\";\r\n      return closeState;\r\n    }\r\n    popContext(state);\r\n    return baseState;\r\n  }\r\n  function closeStateErr(type, stream, state) {\r\n    setStyle = \"error\";\r\n    return closeState(type, stream, state);\r\n  }\r\n\r\n  function attrState(type, _stream, state) {\r\n    if (type == \"word\") {\r\n      setStyle = \"attribute\";\r\n      return attrEqState;\r\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\r\n      var tagName = state.tagName, tagStart = state.tagStart;\r\n      state.tagName = state.tagStart = null;\r\n      if (type == \"selfcloseTag\" ||\r\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\r\n        maybePopContext(state, tagName);\r\n      } else {\r\n        maybePopContext(state, tagName);\r\n        state.context = new Context(state, tagName, tagStart == state.indented);\r\n      }\r\n      return baseState;\r\n    }\r\n    setStyle = \"error\";\r\n    return attrState;\r\n  }\r\n  function attrEqState(type, stream, state) {\r\n    if (type == \"equals\") return attrValueState;\r\n    if (!config.allowMissing) setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrValueState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\r\n    setStyle = \"error\";\r\n    return attrState(type, stream, state);\r\n  }\r\n  function attrContinuedState(type, stream, state) {\r\n    if (type == \"string\") return attrContinuedState;\r\n    return attrState(type, stream, state);\r\n  }\r\n\r\n  return {\r\n    startState: function(baseIndent) {\r\n      var state = {tokenize: inText,\r\n                   state: baseState,\r\n                   indented: baseIndent || 0,\r\n                   tagName: null, tagStart: null,\r\n                   context: null}\r\n      if (baseIndent != null) state.baseIndent = baseIndent\r\n      return state\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (!state.tagName && stream.sol())\r\n        state.indented = stream.indentation();\r\n\r\n      if (stream.eatSpace()) return null;\r\n      type = null;\r\n      var style = state.tokenize(stream, state);\r\n      if ((style || type) && style != \"comment\") {\r\n        setStyle = null;\r\n        state.state = state.state(type || style, stream, state);\r\n        if (setStyle)\r\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\r\n      }\r\n      return style;\r\n    },\r\n\r\n    indent: function(state, textAfter, fullLine) {\r\n      var context = state.context;\r\n      // Indent multi-line strings (e.g. css).\r\n      if (state.tokenize.isInAttribute) {\r\n        if (state.tagStart == state.indented)\r\n          return state.stringStartCol + 1;\r\n        else\r\n          return state.indented + indentUnit;\r\n      }\r\n      if (context && context.noIndent) return CodeMirror.Pass;\r\n      if (state.tokenize != inTag && state.tokenize != inText)\r\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\r\n      // Indent the starts of attribute names.\r\n      if (state.tagName) {\r\n        if (config.multilineTagIndentPastTag !== false)\r\n          return state.tagStart + state.tagName.length + 2;\r\n        else\r\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\r\n      }\r\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\r\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\r\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\r\n        while (context) {\r\n          if (context.tagName == tagAfter[2]) {\r\n            context = context.prev;\r\n            break;\r\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\r\n            context = context.prev;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      } else if (tagAfter) { // Opening tag spotted\r\n        while (context) {\r\n          var grabbers = config.contextGrabbers[context.tagName];\r\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\r\n            context = context.prev;\r\n          else\r\n            break;\r\n        }\r\n      }\r\n      while (context && context.prev && !context.startOfLine)\r\n        context = context.prev;\r\n      if (context) return context.indent + indentUnit;\r\n      else return state.baseIndent || 0;\r\n    },\r\n\r\n    electricInput: /<\\/[\\s\\w:]+>$/,\r\n    blockCommentStart: \"<!--\",\r\n    blockCommentEnd: \"-->\",\r\n\r\n    configuration: config.htmlMode ? \"html\" : \"xml\",\r\n    helperType: config.htmlMode ? \"html\" : \"xml\",\r\n\r\n    skipAttribute: function(state) {\r\n      if (state.state == attrValueState)\r\n        state.state = attrState\r\n    }\r\n  };\r\n});\r\n\r\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\r\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\r\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\r\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/mode/css/css',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\r\n  var inline = parserConfig.inline\r\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\r\n\r\n  var indentUnit = config.indentUnit,\r\n      tokenHooks = parserConfig.tokenHooks,\r\n      documentTypes = parserConfig.documentTypes || {},\r\n      mediaTypes = parserConfig.mediaTypes || {},\r\n      mediaFeatures = parserConfig.mediaFeatures || {},\r\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\r\n      propertyKeywords = parserConfig.propertyKeywords || {},\r\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\r\n      fontProperties = parserConfig.fontProperties || {},\r\n      counterDescriptors = parserConfig.counterDescriptors || {},\r\n      colorKeywords = parserConfig.colorKeywords || {},\r\n      valueKeywords = parserConfig.valueKeywords || {},\r\n      allowNested = parserConfig.allowNested,\r\n      lineComment = parserConfig.lineComment,\r\n      supportsAtComponent = parserConfig.supportsAtComponent === true;\r\n\r\n  var type, override;\r\n  function ret(style, tp) { type = tp; return style; }\r\n\r\n  // Tokenizers\r\n\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.next();\r\n    if (tokenHooks[ch]) {\r\n      var result = tokenHooks[ch](stream, state);\r\n      if (result !== false) return result;\r\n    }\r\n    if (ch == \"@\") {\r\n      stream.eatWhile(/[\\w\\\\\\-]/);\r\n      return ret(\"def\", stream.current());\r\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\r\n      return ret(null, \"compare\");\r\n    } else if (ch == \"\\\"\" || ch == \"'\") {\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    } else if (ch == \"#\") {\r\n      stream.eatWhile(/[\\w\\\\\\-]/);\r\n      return ret(\"atom\", \"hash\");\r\n    } else if (ch == \"!\") {\r\n      stream.match(/^\\s*\\w*/);\r\n      return ret(\"keyword\", \"important\");\r\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\r\n      stream.eatWhile(/[\\w.%]/);\r\n      return ret(\"number\", \"unit\");\r\n    } else if (ch === \"-\") {\r\n      if (/[\\d.]/.test(stream.peek())) {\r\n        stream.eatWhile(/[\\w.%]/);\r\n        return ret(\"number\", \"unit\");\r\n      } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\r\n        stream.eatWhile(/[\\w\\\\\\-]/);\r\n        if (stream.match(/^\\s*:/, false))\r\n          return ret(\"variable-2\", \"variable-definition\");\r\n        return ret(\"variable-2\", \"variable\");\r\n      } else if (stream.match(/^\\w+-/)) {\r\n        return ret(\"meta\", \"meta\");\r\n      }\r\n    } else if (/[,+>*\\/]/.test(ch)) {\r\n      return ret(null, \"select-op\");\r\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\r\n      return ret(\"qualifier\", \"qualifier\");\r\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\r\n      return ret(null, ch);\r\n    } else if (stream.match(/[\\w-.]+(?=\\()/)) {\r\n      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {\r\n        state.tokenize = tokenParenthesized;\r\n      }\r\n      return ret(\"variable callee\", \"variable\");\r\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\r\n      stream.eatWhile(/[\\w\\\\\\-]/);\r\n      return ret(\"property\", \"word\");\r\n    } else {\r\n      return ret(null, null);\r\n    }\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, ch;\r\n      while ((ch = stream.next()) != null) {\r\n        if (ch == quote && !escaped) {\r\n          if (quote == \")\") stream.backUp(1);\r\n          break;\r\n        }\r\n        escaped = !escaped && ch == \"\\\\\";\r\n      }\r\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\r\n      return ret(\"string\", \"string\");\r\n    };\r\n  }\r\n\r\n  function tokenParenthesized(stream, state) {\r\n    stream.next(); // Must be '('\r\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\r\n      state.tokenize = tokenString(\")\");\r\n    else\r\n      state.tokenize = null;\r\n    return ret(null, \"(\");\r\n  }\r\n\r\n  // Context management\r\n\r\n  function Context(type, indent, prev) {\r\n    this.type = type;\r\n    this.indent = indent;\r\n    this.prev = prev;\r\n  }\r\n\r\n  function pushContext(state, stream, type, indent) {\r\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\r\n    return type;\r\n  }\r\n\r\n  function popContext(state) {\r\n    if (state.context.prev)\r\n      state.context = state.context.prev;\r\n    return state.context.type;\r\n  }\r\n\r\n  function pass(type, stream, state) {\r\n    return states[state.context.type](type, stream, state);\r\n  }\r\n  function popAndPass(type, stream, state, n) {\r\n    for (var i = n || 1; i > 0; i--)\r\n      state.context = state.context.prev;\r\n    return pass(type, stream, state);\r\n  }\r\n\r\n  // Parser\r\n\r\n  function wordAsValue(stream) {\r\n    var word = stream.current().toLowerCase();\r\n    if (valueKeywords.hasOwnProperty(word))\r\n      override = \"atom\";\r\n    else if (colorKeywords.hasOwnProperty(word))\r\n      override = \"keyword\";\r\n    else\r\n      override = \"variable\";\r\n  }\r\n\r\n  var states = {};\r\n\r\n  states.top = function(type, stream, state) {\r\n    if (type == \"{\") {\r\n      return pushContext(state, stream, \"block\");\r\n    } else if (type == \"}\" && state.context.prev) {\r\n      return popContext(state);\r\n    } else if (supportsAtComponent && /@component/i.test(type)) {\r\n      return pushContext(state, stream, \"atComponentBlock\");\r\n    } else if (/^@(-moz-)?document$/i.test(type)) {\r\n      return pushContext(state, stream, \"documentTypes\");\r\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\r\n      return pushContext(state, stream, \"atBlock\");\r\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\r\n      state.stateArg = type;\r\n      return \"restricted_atBlock_before\";\r\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\r\n      return \"keyframes\";\r\n    } else if (type && type.charAt(0) == \"@\") {\r\n      return pushContext(state, stream, \"at\");\r\n    } else if (type == \"hash\") {\r\n      override = \"builtin\";\r\n    } else if (type == \"word\") {\r\n      override = \"tag\";\r\n    } else if (type == \"variable-definition\") {\r\n      return \"maybeprop\";\r\n    } else if (type == \"interpolation\") {\r\n      return pushContext(state, stream, \"interpolation\");\r\n    } else if (type == \":\") {\r\n      return \"pseudo\";\r\n    } else if (allowNested && type == \"(\") {\r\n      return pushContext(state, stream, \"parens\");\r\n    }\r\n    return state.context.type;\r\n  };\r\n\r\n  states.block = function(type, stream, state) {\r\n    if (type == \"word\") {\r\n      var word = stream.current().toLowerCase();\r\n      if (propertyKeywords.hasOwnProperty(word)) {\r\n        override = \"property\";\r\n        return \"maybeprop\";\r\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\r\n        override = \"string-2\";\r\n        return \"maybeprop\";\r\n      } else if (allowNested) {\r\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\r\n        return \"block\";\r\n      } else {\r\n        override += \" error\";\r\n        return \"maybeprop\";\r\n      }\r\n    } else if (type == \"meta\") {\r\n      return \"block\";\r\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\r\n      override = \"error\";\r\n      return \"block\";\r\n    } else {\r\n      return states.top(type, stream, state);\r\n    }\r\n  };\r\n\r\n  states.maybeprop = function(type, stream, state) {\r\n    if (type == \":\") return pushContext(state, stream, \"prop\");\r\n    return pass(type, stream, state);\r\n  };\r\n\r\n  states.prop = function(type, stream, state) {\r\n    if (type == \";\") return popContext(state);\r\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\r\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\r\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\r\n\r\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\r\n      override += \" error\";\r\n    } else if (type == \"word\") {\r\n      wordAsValue(stream);\r\n    } else if (type == \"interpolation\") {\r\n      return pushContext(state, stream, \"interpolation\");\r\n    }\r\n    return \"prop\";\r\n  };\r\n\r\n  states.propBlock = function(type, _stream, state) {\r\n    if (type == \"}\") return popContext(state);\r\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\r\n    return state.context.type;\r\n  };\r\n\r\n  states.parens = function(type, stream, state) {\r\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\r\n    if (type == \")\") return popContext(state);\r\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\r\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\r\n    if (type == \"word\") wordAsValue(stream);\r\n    return \"parens\";\r\n  };\r\n\r\n  states.pseudo = function(type, stream, state) {\r\n    if (type == \"meta\") return \"pseudo\";\r\n\r\n    if (type == \"word\") {\r\n      override = \"variable-3\";\r\n      return state.context.type;\r\n    }\r\n    return pass(type, stream, state);\r\n  };\r\n\r\n  states.documentTypes = function(type, stream, state) {\r\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\r\n      override = \"tag\";\r\n      return state.context.type;\r\n    } else {\r\n      return states.atBlock(type, stream, state);\r\n    }\r\n  };\r\n\r\n  states.atBlock = function(type, stream, state) {\r\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\r\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\r\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\r\n\r\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\r\n\r\n    if (type == \"word\") {\r\n      var word = stream.current().toLowerCase();\r\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\r\n        override = \"keyword\";\r\n      else if (mediaTypes.hasOwnProperty(word))\r\n        override = \"attribute\";\r\n      else if (mediaFeatures.hasOwnProperty(word))\r\n        override = \"property\";\r\n      else if (mediaValueKeywords.hasOwnProperty(word))\r\n        override = \"keyword\";\r\n      else if (propertyKeywords.hasOwnProperty(word))\r\n        override = \"property\";\r\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\r\n        override = \"string-2\";\r\n      else if (valueKeywords.hasOwnProperty(word))\r\n        override = \"atom\";\r\n      else if (colorKeywords.hasOwnProperty(word))\r\n        override = \"keyword\";\r\n      else\r\n        override = \"error\";\r\n    }\r\n    return state.context.type;\r\n  };\r\n\r\n  states.atComponentBlock = function(type, stream, state) {\r\n    if (type == \"}\")\r\n      return popAndPass(type, stream, state);\r\n    if (type == \"{\")\r\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\r\n    if (type == \"word\")\r\n      override = \"error\";\r\n    return state.context.type;\r\n  };\r\n\r\n  states.atBlock_parens = function(type, stream, state) {\r\n    if (type == \")\") return popContext(state);\r\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\r\n    return states.atBlock(type, stream, state);\r\n  };\r\n\r\n  states.restricted_atBlock_before = function(type, stream, state) {\r\n    if (type == \"{\")\r\n      return pushContext(state, stream, \"restricted_atBlock\");\r\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\r\n      override = \"variable\";\r\n      return \"restricted_atBlock_before\";\r\n    }\r\n    return pass(type, stream, state);\r\n  };\r\n\r\n  states.restricted_atBlock = function(type, stream, state) {\r\n    if (type == \"}\") {\r\n      state.stateArg = null;\r\n      return popContext(state);\r\n    }\r\n    if (type == \"word\") {\r\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\r\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\r\n        override = \"error\";\r\n      else\r\n        override = \"property\";\r\n      return \"maybeprop\";\r\n    }\r\n    return \"restricted_atBlock\";\r\n  };\r\n\r\n  states.keyframes = function(type, stream, state) {\r\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\r\n    if (type == \"{\") return pushContext(state, stream, \"top\");\r\n    return pass(type, stream, state);\r\n  };\r\n\r\n  states.at = function(type, stream, state) {\r\n    if (type == \";\") return popContext(state);\r\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\r\n    if (type == \"word\") override = \"tag\";\r\n    else if (type == \"hash\") override = \"builtin\";\r\n    return \"at\";\r\n  };\r\n\r\n  states.interpolation = function(type, stream, state) {\r\n    if (type == \"}\") return popContext(state);\r\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\r\n    if (type == \"word\") override = \"variable\";\r\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\r\n    return \"interpolation\";\r\n  };\r\n\r\n  return {\r\n    startState: function(base) {\r\n      return {tokenize: null,\r\n              state: inline ? \"block\" : \"top\",\r\n              stateArg: null,\r\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (!state.tokenize && stream.eatSpace()) return null;\r\n      var style = (state.tokenize || tokenBase)(stream, state);\r\n      if (style && typeof style == \"object\") {\r\n        type = style[1];\r\n        style = style[0];\r\n      }\r\n      override = style;\r\n      if (type != \"comment\")\r\n        state.state = states[state.state](type, stream, state);\r\n      return override;\r\n    },\r\n\r\n    indent: function(state, textAfter) {\r\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\r\n      var indent = cx.indent;\r\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\r\n      if (cx.prev) {\r\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\r\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\r\n          // Resume indentation from parent context.\r\n          cx = cx.prev;\r\n          indent = cx.indent;\r\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\r\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\r\n          // Dedent relative to current context.\r\n          indent = Math.max(0, cx.indent - indentUnit);\r\n        }\r\n      }\r\n      return indent;\r\n    },\r\n\r\n    electricChars: \"}\",\r\n    blockCommentStart: \"/*\",\r\n    blockCommentEnd: \"*/\",\r\n    blockCommentContinue: \" * \",\r\n    lineComment: lineComment,\r\n    fold: \"brace\"\r\n  };\r\n});\r\n\r\n  function keySet(array) {\r\n    var keys = {};\r\n    for (var i = 0; i < array.length; ++i) {\r\n      keys[array[i].toLowerCase()] = true;\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  var documentTypes_ = [\r\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\r\n  ], documentTypes = keySet(documentTypes_);\r\n\r\n  var mediaTypes_ = [\r\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\r\n    \"tty\", \"tv\", \"embossed\"\r\n  ], mediaTypes = keySet(mediaTypes_);\r\n\r\n  var mediaFeatures_ = [\r\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\r\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\r\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\r\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\r\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\r\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\r\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\r\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\r\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\r\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\r\n  ], mediaFeatures = keySet(mediaFeatures_);\r\n\r\n  var mediaValueKeywords_ = [\r\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\r\n    \"interlace\", \"progressive\"\r\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\r\n\r\n  var propertyKeywords_ = [\r\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\r\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\r\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\r\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\r\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\r\n    \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\",\r\n    \"background-color\", \"background-image\", \"background-origin\", \"background-position\",\r\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\r\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\r\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\r\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\r\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\r\n    \"border-color\", \"border-image\", \"border-image-outset\",\r\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\r\n    \"border-image-width\", \"border-left\", \"border-left-color\",\r\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\r\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\r\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\r\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\r\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\r\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\r\n    \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\r\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\r\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\r\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\r\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\r\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\r\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\r\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\r\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\r\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\r\n    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\r\n    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\r\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\r\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\r\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\r\n    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\r\n    \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\",\r\n    \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\",\r\n    \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\r\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\r\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\r\n    \"inline-box-align\", \"justify-content\", \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\",\r\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\r\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\r\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\r\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\r\n    \"marks\", \"marquee-direction\", \"marquee-loop\",\r\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\r\n    \"max-width\", \"min-height\", \"min-width\", \"mix-blend-mode\", \"move-to\", \"nav-down\", \"nav-index\",\r\n    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\r\n    \"opacity\", \"order\", \"orphans\", \"outline\",\r\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\r\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\r\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\r\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\r\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\r\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\", \"position\",\r\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\r\n    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\r\n    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\r\n    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\r\n    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\r\n    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\r\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\r\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\r\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\r\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\r\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\r\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\r\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\r\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\r\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\r\n    \"transition\", \"transition-delay\", \"transition-duration\",\r\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\r\n    \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\r\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\r\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\",\r\n    \"word-spacing\", \"word-wrap\", \"z-index\",\r\n    // SVG-specific\r\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\r\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\r\n    \"color-interpolation\", \"color-interpolation-filters\",\r\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\r\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\r\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\r\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\r\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\r\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\r\n  ], propertyKeywords = keySet(propertyKeywords_);\r\n\r\n  var nonStandardPropertyKeywords_ = [\r\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\r\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\r\n    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\r\n    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\r\n    \"searchfield-results-decoration\", \"zoom\"\r\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\r\n\r\n  var fontProperties_ = [\r\n    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\r\n    \"font-stretch\", \"font-weight\", \"font-style\"\r\n  ], fontProperties = keySet(fontProperties_);\r\n\r\n  var counterDescriptors_ = [\r\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\r\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\r\n  ], counterDescriptors = keySet(counterDescriptors_);\r\n\r\n  var colorKeywords_ = [\r\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\r\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\r\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\r\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\r\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\r\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\r\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\r\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\r\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\r\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\r\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\r\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\r\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\r\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\r\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\r\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\r\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\r\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\r\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\r\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\r\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\r\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\r\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\r\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\r\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\r\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\r\n  ], colorKeywords = keySet(colorKeywords_);\r\n\r\n  var valueKeywords_ = [\r\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\r\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\r\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\r\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\r\n    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\r\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\r\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\r\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\r\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\r\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\r\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\r\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\r\n    \"compact\", \"condensed\", \"contain\", \"content\", \"contents\",\r\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\r\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\r\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\r\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\r\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\r\n    \"dot-dash\", \"dot-dot-dash\",\r\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\r\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\r\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\r\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\r\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\r\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\r\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\r\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\r\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\r\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\r\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"grid\", \"groove\",\r\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\r\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\r\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\r\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\r\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\r\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\r\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\r\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\r\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\r\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\r\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\r\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\r\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\r\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\r\n    \"media-controls-background\", \"media-current-time-display\",\r\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\r\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\r\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\r\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\r\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\r\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\r\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\r\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiply\", \"myanmar\", \"n-resize\",\r\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\r\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\r\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\r\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\r\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\r\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\r\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\r\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\r\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\r\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\r\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\r\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\r\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\r\n    \"s-resize\", \"sans-serif\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\r\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\r\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\r\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\r\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\r\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\r\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\r\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\r\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\r\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\r\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\r\n    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\r\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\r\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\r\n    \"tamil\",\r\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\r\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\r\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\r\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\r\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\r\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\r\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unset\", \"up\",\r\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\r\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\r\n    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\r\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\r\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\r\n    \"xx-large\", \"xx-small\"\r\n  ], valueKeywords = keySet(valueKeywords_);\r\n\r\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\r\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\r\n    .concat(valueKeywords_);\r\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\r\n\r\n  function tokenCComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while ((ch = stream.next()) != null) {\r\n      if (maybeEnd && ch == \"/\") {\r\n        state.tokenize = null;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return [\"comment\", \"comment\"];\r\n  }\r\n\r\n  CodeMirror.defineMIME(\"text/css\", {\r\n    documentTypes: documentTypes,\r\n    mediaTypes: mediaTypes,\r\n    mediaFeatures: mediaFeatures,\r\n    mediaValueKeywords: mediaValueKeywords,\r\n    propertyKeywords: propertyKeywords,\r\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\r\n    fontProperties: fontProperties,\r\n    counterDescriptors: counterDescriptors,\r\n    colorKeywords: colorKeywords,\r\n    valueKeywords: valueKeywords,\r\n    tokenHooks: {\r\n      \"/\": function(stream, state) {\r\n        if (!stream.eat(\"*\")) return false;\r\n        state.tokenize = tokenCComment;\r\n        return tokenCComment(stream, state);\r\n      }\r\n    },\r\n    name: \"css\"\r\n  });\r\n\r\n  CodeMirror.defineMIME(\"text/x-scss\", {\r\n    mediaTypes: mediaTypes,\r\n    mediaFeatures: mediaFeatures,\r\n    mediaValueKeywords: mediaValueKeywords,\r\n    propertyKeywords: propertyKeywords,\r\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\r\n    colorKeywords: colorKeywords,\r\n    valueKeywords: valueKeywords,\r\n    fontProperties: fontProperties,\r\n    allowNested: true,\r\n    lineComment: \"//\",\r\n    tokenHooks: {\r\n      \"/\": function(stream, state) {\r\n        if (stream.eat(\"/\")) {\r\n          stream.skipToEnd();\r\n          return [\"comment\", \"comment\"];\r\n        } else if (stream.eat(\"*\")) {\r\n          state.tokenize = tokenCComment;\r\n          return tokenCComment(stream, state);\r\n        } else {\r\n          return [\"operator\", \"operator\"];\r\n        }\r\n      },\r\n      \":\": function(stream) {\r\n        if (stream.match(/\\s*\\{/, false))\r\n          return [null, null]\r\n        return false;\r\n      },\r\n      \"$\": function(stream) {\r\n        stream.match(/^[\\w-]+/);\r\n        if (stream.match(/^\\s*:/, false))\r\n          return [\"variable-2\", \"variable-definition\"];\r\n        return [\"variable-2\", \"variable\"];\r\n      },\r\n      \"#\": function(stream) {\r\n        if (!stream.eat(\"{\")) return false;\r\n        return [null, \"interpolation\"];\r\n      }\r\n    },\r\n    name: \"css\",\r\n    helperType: \"scss\"\r\n  });\r\n\r\n  CodeMirror.defineMIME(\"text/x-less\", {\r\n    mediaTypes: mediaTypes,\r\n    mediaFeatures: mediaFeatures,\r\n    mediaValueKeywords: mediaValueKeywords,\r\n    propertyKeywords: propertyKeywords,\r\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\r\n    colorKeywords: colorKeywords,\r\n    valueKeywords: valueKeywords,\r\n    fontProperties: fontProperties,\r\n    allowNested: true,\r\n    lineComment: \"//\",\r\n    tokenHooks: {\r\n      \"/\": function(stream, state) {\r\n        if (stream.eat(\"/\")) {\r\n          stream.skipToEnd();\r\n          return [\"comment\", \"comment\"];\r\n        } else if (stream.eat(\"*\")) {\r\n          state.tokenize = tokenCComment;\r\n          return tokenCComment(stream, state);\r\n        } else {\r\n          return [\"operator\", \"operator\"];\r\n        }\r\n      },\r\n      \"@\": function(stream) {\r\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\r\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\r\n        stream.eatWhile(/[\\w\\\\\\-]/);\r\n        if (stream.match(/^\\s*:/, false))\r\n          return [\"variable-2\", \"variable-definition\"];\r\n        return [\"variable-2\", \"variable\"];\r\n      },\r\n      \"&\": function() {\r\n        return [\"atom\", \"atom\"];\r\n      }\r\n    },\r\n    name: \"css\",\r\n    helperType: \"less\"\r\n  });\r\n\r\n  CodeMirror.defineMIME(\"text/x-gss\", {\r\n    documentTypes: documentTypes,\r\n    mediaTypes: mediaTypes,\r\n    mediaFeatures: mediaFeatures,\r\n    propertyKeywords: propertyKeywords,\r\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\r\n    fontProperties: fontProperties,\r\n    counterDescriptors: counterDescriptors,\r\n    colorKeywords: colorKeywords,\r\n    valueKeywords: valueKeywords,\r\n    supportsAtComponent: true,\r\n    tokenHooks: {\r\n      \"/\": function(stream, state) {\r\n        if (!stream.eat(\"*\")) return false;\r\n        state.tokenize = tokenCComment;\r\n        return tokenCComment(stream, state);\r\n      }\r\n    },\r\n    name: \"css\",\r\n    helperType: \"gss\"\r\n  });\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/mode/javascript/javascript',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\r\n  var indentUnit = config.indentUnit;\r\n  var statementIndent = parserConfig.statementIndent;\r\n  var jsonldMode = parserConfig.jsonld;\r\n  var jsonMode = parserConfig.json || jsonldMode;\r\n  var isTS = parserConfig.typescript;\r\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\r\n\r\n  // Tokenizer\r\n\r\n  var keywords = function(){\r\n    function kw(type) {return {type: type, style: \"keyword\"};}\r\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\r\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\r\n\r\n    return {\r\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\r\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\r\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\r\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\r\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\r\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\r\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\r\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\r\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\r\n      \"await\": C\r\n    };\r\n  }();\r\n\r\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\r\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\r\n\r\n  function readRegexp(stream) {\r\n    var escaped = false, next, inSet = false;\r\n    while ((next = stream.next()) != null) {\r\n      if (!escaped) {\r\n        if (next == \"/\" && !inSet) return;\r\n        if (next == \"[\") inSet = true;\r\n        else if (inSet && next == \"]\") inSet = false;\r\n      }\r\n      escaped = !escaped && next == \"\\\\\";\r\n    }\r\n  }\r\n\r\n  // Used as scratch variables to communicate multiple values without\r\n  // consing up tons of objects.\r\n  var type, content;\r\n  function ret(tp, style, cont) {\r\n    type = tp; content = cont;\r\n    return style;\r\n  }\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.next();\r\n    if (ch == '\"' || ch == \"'\") {\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \".\" && stream.match(\"..\")) {\r\n      return ret(\"spread\", \"meta\");\r\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\r\n      return ret(ch);\r\n    } else if (ch == \"=\" && stream.eat(\">\")) {\r\n      return ret(\"=>\", \"operator\");\r\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\da-f]+|o[0-7]+|b[01]+)n?/i)) {\r\n      return ret(\"number\", \"number\");\r\n    } else if (/\\d/.test(ch)) {\r\n      stream.match(/^\\d*(?:n|(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/);\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \"/\") {\r\n      if (stream.eat(\"*\")) {\r\n        state.tokenize = tokenComment;\r\n        return tokenComment(stream, state);\r\n      } else if (stream.eat(\"/\")) {\r\n        stream.skipToEnd();\r\n        return ret(\"comment\", \"comment\");\r\n      } else if (expressionAllowed(stream, state, 1)) {\r\n        readRegexp(stream);\r\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\r\n        return ret(\"regexp\", \"string-2\");\r\n      } else {\r\n        stream.eat(\"=\");\r\n        return ret(\"operator\", \"operator\", stream.current());\r\n      }\r\n    } else if (ch == \"`\") {\r\n      state.tokenize = tokenQuasi;\r\n      return tokenQuasi(stream, state);\r\n    } else if (ch == \"#\") {\r\n      stream.skipToEnd();\r\n      return ret(\"error\", \"error\");\r\n    } else if (isOperatorChar.test(ch)) {\r\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\r\n        if (stream.eat(\"=\")) {\r\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\r\n        } else if (/[<>*+\\-]/.test(ch)) {\r\n          stream.eat(ch)\r\n          if (ch == \">\") stream.eat(ch)\r\n        }\r\n      }\r\n      return ret(\"operator\", \"operator\", stream.current());\r\n    } else if (wordRE.test(ch)) {\r\n      stream.eatWhile(wordRE);\r\n      var word = stream.current()\r\n      if (state.lastType != \".\") {\r\n        if (keywords.propertyIsEnumerable(word)) {\r\n          var kw = keywords[word]\r\n          return ret(kw.type, kw.style, word)\r\n        }\r\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*.*?\\*\\/)*[\\[\\(\\w]/, false))\r\n          return ret(\"async\", \"keyword\", word)\r\n      }\r\n      return ret(\"variable\", \"variable\", word)\r\n    }\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, next;\r\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\r\n        state.tokenize = tokenBase;\r\n        return ret(\"jsonld-keyword\", \"meta\");\r\n      }\r\n      while ((next = stream.next()) != null) {\r\n        if (next == quote && !escaped) break;\r\n        escaped = !escaped && next == \"\\\\\";\r\n      }\r\n      if (!escaped) state.tokenize = tokenBase;\r\n      return ret(\"string\", \"string\");\r\n    };\r\n  }\r\n\r\n  function tokenComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while (ch = stream.next()) {\r\n      if (ch == \"/\" && maybeEnd) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return ret(\"comment\", \"comment\");\r\n  }\r\n\r\n  function tokenQuasi(stream, state) {\r\n    var escaped = false, next;\r\n    while ((next = stream.next()) != null) {\r\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      escaped = !escaped && next == \"\\\\\";\r\n    }\r\n    return ret(\"quasi\", \"string-2\", stream.current());\r\n  }\r\n\r\n  var brackets = \"([{}])\";\r\n  // This is a crude lookahead trick to try and notice that we're\r\n  // parsing the argument patterns for a fat-arrow function before we\r\n  // actually hit the arrow token. It only works if the arrow is on\r\n  // the same line as the arguments and there's no strange noise\r\n  // (comments) in between. Fallback is to only notice when we hit the\r\n  // arrow, and not declare the arguments as locals for the arrow\r\n  // body.\r\n  function findFatArrow(stream, state) {\r\n    if (state.fatArrowAt) state.fatArrowAt = null;\r\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\r\n    if (arrow < 0) return;\r\n\r\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\r\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\r\n      if (m) arrow = m.index\r\n    }\r\n\r\n    var depth = 0, sawSomething = false;\r\n    for (var pos = arrow - 1; pos >= 0; --pos) {\r\n      var ch = stream.string.charAt(pos);\r\n      var bracket = brackets.indexOf(ch);\r\n      if (bracket >= 0 && bracket < 3) {\r\n        if (!depth) { ++pos; break; }\r\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\r\n      } else if (bracket >= 3 && bracket < 6) {\r\n        ++depth;\r\n      } else if (wordRE.test(ch)) {\r\n        sawSomething = true;\r\n      } else if (/[\"'\\/]/.test(ch)) {\r\n        return;\r\n      } else if (sawSomething && !depth) {\r\n        ++pos;\r\n        break;\r\n      }\r\n    }\r\n    if (sawSomething && !depth) state.fatArrowAt = pos;\r\n  }\r\n\r\n  // Parser\r\n\r\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\r\n\r\n  function JSLexical(indented, column, type, align, prev, info) {\r\n    this.indented = indented;\r\n    this.column = column;\r\n    this.type = type;\r\n    this.prev = prev;\r\n    this.info = info;\r\n    if (align != null) this.align = align;\r\n  }\r\n\r\n  function inScope(state, varname) {\r\n    for (var v = state.localVars; v; v = v.next)\r\n      if (v.name == varname) return true;\r\n    for (var cx = state.context; cx; cx = cx.prev) {\r\n      for (var v = cx.vars; v; v = v.next)\r\n        if (v.name == varname) return true;\r\n    }\r\n  }\r\n\r\n  function parseJS(state, style, type, content, stream) {\r\n    var cc = state.cc;\r\n    // Communicate our context to the combinators.\r\n    // (Less wasteful than consing up a hundred closures on every call.)\r\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\r\n\r\n    if (!state.lexical.hasOwnProperty(\"align\"))\r\n      state.lexical.align = true;\r\n\r\n    while(true) {\r\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\r\n      if (combinator(type, content)) {\r\n        while(cc.length && cc[cc.length - 1].lex)\r\n          cc.pop()();\r\n        if (cx.marked) return cx.marked;\r\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\r\n        return style;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Combinator utils\r\n\r\n  var cx = {state: null, column: null, marked: null, cc: null};\r\n  function pass() {\r\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\r\n  }\r\n  function cont() {\r\n    pass.apply(null, arguments);\r\n    return true;\r\n  }\r\n  function inList(name, list) {\r\n    for (var v = list; v; v = v.next) if (v.name == name) return true\r\n    return false;\r\n  }\r\n  function register(varname) {\r\n    var state = cx.state;\r\n    cx.marked = \"def\";\r\n    if (state.context) {\r\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\r\n        // FIXME function decls are also not block scoped\r\n        var newContext = registerVarScoped(varname, state.context)\r\n        if (newContext != null) {\r\n          state.context = newContext\r\n          return\r\n        }\r\n      } else if (!inList(varname, state.localVars)) {\r\n        state.localVars = new Var(varname, state.localVars)\r\n        return\r\n      }\r\n    }\r\n    // Fall through means this is global\r\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\r\n      state.globalVars = new Var(varname, state.globalVars)\r\n  }\r\n  function registerVarScoped(varname, context) {\r\n    if (!context) {\r\n      return null\r\n    } else if (context.block) {\r\n      var inner = registerVarScoped(varname, context.prev)\r\n      if (!inner) return null\r\n      if (inner == context.prev) return context\r\n      return new Context(inner, context.vars, true)\r\n    } else if (inList(varname, context.vars)) {\r\n      return context\r\n    } else {\r\n      return new Context(context.prev, new Var(varname, context.vars), false)\r\n    }\r\n  }\r\n\r\n  function isModifier(name) {\r\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\r\n  }\r\n\r\n  // Combinators\r\n\r\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\r\n  function Var(name, next) { this.name = name; this.next = next }\r\n\r\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\r\n  function pushcontext() {\r\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\r\n    cx.state.localVars = defaultVars\r\n  }\r\n  function pushblockcontext() {\r\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\r\n    cx.state.localVars = null\r\n  }\r\n  function popcontext() {\r\n    cx.state.localVars = cx.state.context.vars\r\n    cx.state.context = cx.state.context.prev\r\n  }\r\n  popcontext.lex = true\r\n  function pushlex(type, info) {\r\n    var result = function() {\r\n      var state = cx.state, indent = state.indented;\r\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\r\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\r\n        indent = outer.indented;\r\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\r\n    };\r\n    result.lex = true;\r\n    return result;\r\n  }\r\n  function poplex() {\r\n    var state = cx.state;\r\n    if (state.lexical.prev) {\r\n      if (state.lexical.type == \")\")\r\n        state.indented = state.lexical.indented;\r\n      state.lexical = state.lexical.prev;\r\n    }\r\n  }\r\n  poplex.lex = true;\r\n\r\n  function expect(wanted) {\r\n    function exp(type) {\r\n      if (type == wanted) return cont();\r\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\r\n      else return cont(exp);\r\n    };\r\n    return exp;\r\n  }\r\n\r\n  function statement(type, value) {\r\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\r\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\r\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\r\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\r\n    if (type == \"debugger\") return cont(expect(\";\"));\r\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\r\n    if (type == \";\") return cont();\r\n    if (type == \"if\") {\r\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\r\n        cx.state.cc.pop()();\r\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\r\n    }\r\n    if (type == \"function\") return cont(functiondef);\r\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\r\n    if (type == \"class\" || (isTS && value == \"interface\")) {\r\n      cx.marked = \"keyword\"\r\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\r\n    }\r\n    if (type == \"variable\") {\r\n      if (isTS && value == \"declare\") {\r\n        cx.marked = \"keyword\"\r\n        return cont(statement)\r\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\r\n        cx.marked = \"keyword\"\r\n        if (value == \"enum\") return cont(enumdef);\r\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\r\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\r\n      } else if (isTS && value == \"namespace\") {\r\n        cx.marked = \"keyword\"\r\n        return cont(pushlex(\"form\"), expression, statement, poplex)\r\n      } else if (isTS && value == \"abstract\") {\r\n        cx.marked = \"keyword\"\r\n        return cont(statement)\r\n      } else {\r\n        return cont(pushlex(\"stat\"), maybelabel);\r\n      }\r\n    }\r\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\r\n                                      block, poplex, poplex, popcontext);\r\n    if (type == \"case\") return cont(expression, expect(\":\"));\r\n    if (type == \"default\") return cont(expect(\":\"));\r\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\r\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\r\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\r\n    if (type == \"async\") return cont(statement)\r\n    if (value == \"@\") return cont(expression, statement)\r\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\r\n  }\r\n  function maybeCatchBinding(type) {\r\n    if (type == \"(\") return cont(funarg, expect(\")\"))\r\n  }\r\n  function expression(type, value) {\r\n    return expressionInner(type, value, false);\r\n  }\r\n  function expressionNoComma(type, value) {\r\n    return expressionInner(type, value, true);\r\n  }\r\n  function parenExpr(type) {\r\n    if (type != \"(\") return pass()\r\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\r\n  }\r\n  function expressionInner(type, value, noComma) {\r\n    if (cx.state.fatArrowAt == cx.stream.start) {\r\n      var body = noComma ? arrowBodyNoComma : arrowBody;\r\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\r\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\r\n    }\r\n\r\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\r\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\r\n    if (type == \"function\") return cont(functiondef, maybeop);\r\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\r\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\r\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\r\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\r\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\r\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\r\n    if (type == \"quasi\") return pass(quasi, maybeop);\r\n    if (type == \"new\") return cont(maybeTarget(noComma));\r\n    if (type == \"import\") return cont(expression);\r\n    return cont();\r\n  }\r\n  function maybeexpression(type) {\r\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\r\n    return pass(expression);\r\n  }\r\n\r\n  function maybeoperatorComma(type, value) {\r\n    if (type == \",\") return cont(expression);\r\n    return maybeoperatorNoComma(type, value, false);\r\n  }\r\n  function maybeoperatorNoComma(type, value, noComma) {\r\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\r\n    var expr = noComma == false ? expression : expressionNoComma;\r\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\r\n    if (type == \"operator\") {\r\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\r\n      if (isTS && value == \"<\" && cx.stream.match(/^([^>]|<.*?>)*>\\s*\\(/, false))\r\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\r\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\r\n      return cont(expr);\r\n    }\r\n    if (type == \"quasi\") { return pass(quasi, me); }\r\n    if (type == \";\") return;\r\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\r\n    if (type == \".\") return cont(property, me);\r\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\r\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\r\n    if (type == \"regexp\") {\r\n      cx.state.lastType = cx.marked = \"operator\"\r\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\r\n      return cont(expr)\r\n    }\r\n  }\r\n  function quasi(type, value) {\r\n    if (type != \"quasi\") return pass();\r\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\r\n    return cont(expression, continueQuasi);\r\n  }\r\n  function continueQuasi(type) {\r\n    if (type == \"}\") {\r\n      cx.marked = \"string-2\";\r\n      cx.state.tokenize = tokenQuasi;\r\n      return cont(quasi);\r\n    }\r\n  }\r\n  function arrowBody(type) {\r\n    findFatArrow(cx.stream, cx.state);\r\n    return pass(type == \"{\" ? statement : expression);\r\n  }\r\n  function arrowBodyNoComma(type) {\r\n    findFatArrow(cx.stream, cx.state);\r\n    return pass(type == \"{\" ? statement : expressionNoComma);\r\n  }\r\n  function maybeTarget(noComma) {\r\n    return function(type) {\r\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\r\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\r\n      else return pass(noComma ? expressionNoComma : expression);\r\n    };\r\n  }\r\n  function target(_, value) {\r\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\r\n  }\r\n  function targetNoComma(_, value) {\r\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\r\n  }\r\n  function maybelabel(type) {\r\n    if (type == \":\") return cont(poplex, statement);\r\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\r\n  }\r\n  function property(type) {\r\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\r\n  }\r\n  function objprop(type, value) {\r\n    if (type == \"async\") {\r\n      cx.marked = \"property\";\r\n      return cont(objprop);\r\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\r\n      cx.marked = \"property\";\r\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\r\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\r\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\r\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\r\n      return cont(afterprop);\r\n    } else if (type == \"number\" || type == \"string\") {\r\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\r\n      return cont(afterprop);\r\n    } else if (type == \"jsonld-keyword\") {\r\n      return cont(afterprop);\r\n    } else if (isTS && isModifier(value)) {\r\n      cx.marked = \"keyword\"\r\n      return cont(objprop)\r\n    } else if (type == \"[\") {\r\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\r\n    } else if (type == \"spread\") {\r\n      return cont(expressionNoComma, afterprop);\r\n    } else if (value == \"*\") {\r\n      cx.marked = \"keyword\";\r\n      return cont(objprop);\r\n    } else if (type == \":\") {\r\n      return pass(afterprop)\r\n    }\r\n  }\r\n  function getterSetter(type) {\r\n    if (type != \"variable\") return pass(afterprop);\r\n    cx.marked = \"property\";\r\n    return cont(functiondef);\r\n  }\r\n  function afterprop(type) {\r\n    if (type == \":\") return cont(expressionNoComma);\r\n    if (type == \"(\") return pass(functiondef);\r\n  }\r\n  function commasep(what, end, sep) {\r\n    function proceed(type, value) {\r\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\r\n        var lex = cx.state.lexical;\r\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\r\n        return cont(function(type, value) {\r\n          if (type == end || value == end) return pass()\r\n          return pass(what)\r\n        }, proceed);\r\n      }\r\n      if (type == end || value == end) return cont();\r\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\r\n      return cont(expect(end));\r\n    }\r\n    return function(type, value) {\r\n      if (type == end || value == end) return cont();\r\n      return pass(what, proceed);\r\n    };\r\n  }\r\n  function contCommasep(what, end, info) {\r\n    for (var i = 3; i < arguments.length; i++)\r\n      cx.cc.push(arguments[i]);\r\n    return cont(pushlex(end, info), commasep(what, end), poplex);\r\n  }\r\n  function block(type) {\r\n    if (type == \"}\") return cont();\r\n    return pass(statement, block);\r\n  }\r\n  function maybetype(type, value) {\r\n    if (isTS) {\r\n      if (type == \":\" || value == \"in\") return cont(typeexpr);\r\n      if (value == \"?\") return cont(maybetype);\r\n    }\r\n  }\r\n  function mayberettype(type) {\r\n    if (isTS && type == \":\") {\r\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\r\n      else return cont(typeexpr)\r\n    }\r\n  }\r\n  function isKW(_, value) {\r\n    if (value == \"is\") {\r\n      cx.marked = \"keyword\"\r\n      return cont()\r\n    }\r\n  }\r\n  function typeexpr(type, value) {\r\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\") {\r\n      cx.marked = \"keyword\"\r\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\r\n    }\r\n    if (type == \"variable\" || value == \"void\") {\r\n      cx.marked = \"type\"\r\n      return cont(afterType)\r\n    }\r\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\r\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\r\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\r\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\r\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\r\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\r\n  }\r\n  function maybeReturnType(type) {\r\n    if (type == \"=>\") return cont(typeexpr)\r\n  }\r\n  function typeprop(type, value) {\r\n    if (type == \"variable\" || cx.style == \"keyword\") {\r\n      cx.marked = \"property\"\r\n      return cont(typeprop)\r\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\r\n      return cont(typeprop)\r\n    } else if (type == \":\") {\r\n      return cont(typeexpr)\r\n    } else if (type == \"[\") {\r\n      return cont(expect(\"variable\"), maybetype, expect(\"]\"), typeprop)\r\n    } else if (type == \"(\") {\r\n      return pass(functiondecl, typeprop)\r\n    }\r\n  }\r\n  function typearg(type, value) {\r\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\r\n    if (type == \":\") return cont(typeexpr)\r\n    if (type == \"spread\") return cont(typearg)\r\n    return pass(typeexpr)\r\n  }\r\n  function afterType(type, value) {\r\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\r\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\r\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\r\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\r\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\r\n  }\r\n  function maybeTypeArgs(_, value) {\r\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\r\n  }\r\n  function typeparam() {\r\n    return pass(typeexpr, maybeTypeDefault)\r\n  }\r\n  function maybeTypeDefault(_, value) {\r\n    if (value == \"=\") return cont(typeexpr)\r\n  }\r\n  function vardef(_, value) {\r\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\r\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\r\n  }\r\n  function pattern(type, value) {\r\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\r\n    if (type == \"variable\") { register(value); return cont(); }\r\n    if (type == \"spread\") return cont(pattern);\r\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\r\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\r\n  }\r\n  function proppattern(type, value) {\r\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\r\n      register(value);\r\n      return cont(maybeAssign);\r\n    }\r\n    if (type == \"variable\") cx.marked = \"property\";\r\n    if (type == \"spread\") return cont(pattern);\r\n    if (type == \"}\") return pass();\r\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\r\n    return cont(expect(\":\"), pattern, maybeAssign);\r\n  }\r\n  function eltpattern() {\r\n    return pass(pattern, maybeAssign)\r\n  }\r\n  function maybeAssign(_type, value) {\r\n    if (value == \"=\") return cont(expressionNoComma);\r\n  }\r\n  function vardefCont(type) {\r\n    if (type == \",\") return cont(vardef);\r\n  }\r\n  function maybeelse(type, value) {\r\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\r\n  }\r\n  function forspec(type, value) {\r\n    if (value == \"await\") return cont(forspec);\r\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\r\n  }\r\n  function forspec1(type) {\r\n    if (type == \"var\") return cont(vardef, forspec2);\r\n    if (type == \"variable\") return cont(forspec2);\r\n    return pass(forspec2)\r\n  }\r\n  function forspec2(type, value) {\r\n    if (type == \")\") return cont()\r\n    if (type == \";\") return cont(forspec2)\r\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\r\n    return pass(expression, forspec2)\r\n  }\r\n  function functiondef(type, value) {\r\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\r\n    if (type == \"variable\") {register(value); return cont(functiondef);}\r\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\r\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\r\n  }\r\n  function functiondecl(type, value) {\r\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\r\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\r\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\r\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\r\n  }\r\n  function typename(type, value) {\r\n    if (type == \"keyword\" || type == \"variable\") {\r\n      cx.marked = \"type\"\r\n      return cont(typename)\r\n    } else if (value == \"<\") {\r\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\r\n    }\r\n  }\r\n  function funarg(type, value) {\r\n    if (value == \"@\") cont(expression, funarg)\r\n    if (type == \"spread\") return cont(funarg);\r\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\r\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\r\n    return pass(pattern, maybetype, maybeAssign);\r\n  }\r\n  function classExpression(type, value) {\r\n    // Class expressions may have an optional name.\r\n    if (type == \"variable\") return className(type, value);\r\n    return classNameAfter(type, value);\r\n  }\r\n  function className(type, value) {\r\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\r\n  }\r\n  function classNameAfter(type, value) {\r\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\r\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\r\n      if (value == \"implements\") cx.marked = \"keyword\";\r\n      return cont(isTS ? typeexpr : expression, classNameAfter);\r\n    }\r\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\r\n  }\r\n  function classBody(type, value) {\r\n    if (type == \"async\" ||\r\n        (type == \"variable\" &&\r\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\r\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\r\n      cx.marked = \"keyword\";\r\n      return cont(classBody);\r\n    }\r\n    if (type == \"variable\" || cx.style == \"keyword\") {\r\n      cx.marked = \"property\";\r\n      return cont(isTS ? classfield : functiondef, classBody);\r\n    }\r\n    if (type == \"number\" || type == \"string\") return cont(isTS ? classfield : functiondef, classBody);\r\n    if (type == \"[\")\r\n      return cont(expression, maybetype, expect(\"]\"), isTS ? classfield : functiondef, classBody)\r\n    if (value == \"*\") {\r\n      cx.marked = \"keyword\";\r\n      return cont(classBody);\r\n    }\r\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\r\n    if (type == \";\" || type == \",\") return cont(classBody);\r\n    if (type == \"}\") return cont();\r\n    if (value == \"@\") return cont(expression, classBody)\r\n  }\r\n  function classfield(type, value) {\r\n    if (value == \"?\") return cont(classfield)\r\n    if (type == \":\") return cont(typeexpr, maybeAssign)\r\n    if (value == \"=\") return cont(expressionNoComma)\r\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\r\n    return pass(isInterface ? functiondecl : functiondef)\r\n  }\r\n  function afterExport(type, value) {\r\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\r\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\r\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\r\n    return pass(statement);\r\n  }\r\n  function exportField(type, value) {\r\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\r\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\r\n  }\r\n  function afterImport(type) {\r\n    if (type == \"string\") return cont();\r\n    if (type == \"(\") return pass(expression);\r\n    return pass(importSpec, maybeMoreImports, maybeFrom);\r\n  }\r\n  function importSpec(type, value) {\r\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\r\n    if (type == \"variable\") register(value);\r\n    if (value == \"*\") cx.marked = \"keyword\";\r\n    return cont(maybeAs);\r\n  }\r\n  function maybeMoreImports(type) {\r\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\r\n  }\r\n  function maybeAs(_type, value) {\r\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\r\n  }\r\n  function maybeFrom(_type, value) {\r\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\r\n  }\r\n  function arrayLiteral(type) {\r\n    if (type == \"]\") return cont();\r\n    return pass(commasep(expressionNoComma, \"]\"));\r\n  }\r\n  function enumdef() {\r\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\r\n  }\r\n  function enummember() {\r\n    return pass(pattern, maybeAssign);\r\n  }\r\n\r\n  function isContinuedStatement(state, textAfter) {\r\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\r\n      isOperatorChar.test(textAfter.charAt(0)) ||\r\n      /[,.]/.test(textAfter.charAt(0));\r\n  }\r\n\r\n  function expressionAllowed(stream, state, backUp) {\r\n    return state.tokenize == tokenBase &&\r\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\r\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\r\n  }\r\n\r\n  // Interface\r\n\r\n  return {\r\n    startState: function(basecolumn) {\r\n      var state = {\r\n        tokenize: tokenBase,\r\n        lastType: \"sof\",\r\n        cc: [],\r\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\r\n        localVars: parserConfig.localVars,\r\n        context: parserConfig.localVars && new Context(null, null, false),\r\n        indented: basecolumn || 0\r\n      };\r\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\r\n        state.globalVars = parserConfig.globalVars;\r\n      return state;\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream.sol()) {\r\n        if (!state.lexical.hasOwnProperty(\"align\"))\r\n          state.lexical.align = false;\r\n        state.indented = stream.indentation();\r\n        findFatArrow(stream, state);\r\n      }\r\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\r\n      var style = state.tokenize(stream, state);\r\n      if (type == \"comment\") return style;\r\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\r\n      return parseJS(state, style, type, content, stream);\r\n    },\r\n\r\n    indent: function(state, textAfter) {\r\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\r\n      if (state.tokenize != tokenBase) return 0;\r\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\r\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\r\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\r\n        var c = state.cc[i];\r\n        if (c == poplex) lexical = lexical.prev;\r\n        else if (c != maybeelse) break;\r\n      }\r\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\r\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\r\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\r\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\r\n        lexical = lexical.prev;\r\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\r\n        lexical = lexical.prev;\r\n      var type = lexical.type, closing = firstChar == type;\r\n\r\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\r\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\r\n      else if (type == \"form\") return lexical.indented + indentUnit;\r\n      else if (type == \"stat\")\r\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\r\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\r\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\r\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\r\n      else return lexical.indented + (closing ? 0 : indentUnit);\r\n    },\r\n\r\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\r\n    blockCommentStart: jsonMode ? null : \"/*\",\r\n    blockCommentEnd: jsonMode ? null : \"*/\",\r\n    blockCommentContinue: jsonMode ? null : \" * \",\r\n    lineComment: jsonMode ? null : \"//\",\r\n    fold: \"brace\",\r\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\r\n\r\n    helperType: jsonMode ? \"json\" : \"javascript\",\r\n    jsonldMode: jsonldMode,\r\n    jsonMode: jsonMode,\r\n\r\n    expressionAllowed: expressionAllowed,\r\n\r\n    skipExpression: function(state) {\r\n      var top = state.cc[state.cc.length - 1]\r\n      if (top == expression || top == expressionNoComma) state.cc.pop()\r\n    }\r\n  };\r\n});\r\n\r\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\r\n\r\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\r\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\r\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\r\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\r\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n\r\ndefine('skylark-codemirror/mode/htmlmixed/htmlmixed',[\r\n  \"../../CodeMirror\",\r\n  \"../xml/xml\",\r\n  \"../javascript/javascript\",\r\n  \"../css/css\"\r\n], function(CodeMirror) {\r\n\r\n  \"use strict\";\r\n\r\n  var defaultTags = {\r\n    script: [\r\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\r\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"],\r\n      [\"type\", /./, \"text/plain\"],\r\n      [null, null, \"javascript\"]\r\n    ],\r\n    style:  [\r\n      [\"lang\", /^css$/i, \"css\"],\r\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\r\n      [\"type\", /./, \"text/plain\"],\r\n      [null, null, \"css\"]\r\n    ]\r\n  };\r\n\r\n  function maybeBackup(stream, pat, style) {\r\n    var cur = stream.current(), close = cur.search(pat);\r\n    if (close > -1) {\r\n      stream.backUp(cur.length - close);\r\n    } else if (cur.match(/<\\/?$/)) {\r\n      stream.backUp(cur.length);\r\n      if (!stream.match(pat, false)) stream.match(cur);\r\n    }\r\n    return style;\r\n  }\r\n\r\n  var attrRegexpCache = {};\r\n  function getAttrRegexp(attr) {\r\n    var regexp = attrRegexpCache[attr];\r\n    if (regexp) return regexp;\r\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\r\n  }\r\n\r\n  function getAttrValue(text, attr) {\r\n    var match = text.match(getAttrRegexp(attr))\r\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\"\r\n  }\r\n\r\n  function getTagRegexp(tagName, anchored) {\r\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\r\n  }\r\n\r\n  function addTags(from, to) {\r\n    for (var tag in from) {\r\n      var dest = to[tag] || (to[tag] = []);\r\n      var source = from[tag];\r\n      for (var i = source.length - 1; i >= 0; i--)\r\n        dest.unshift(source[i])\r\n    }\r\n  }\r\n\r\n  function findMatchingMode(tagInfo, tagText) {\r\n    for (var i = 0; i < tagInfo.length; i++) {\r\n      var spec = tagInfo[i];\r\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\r\n    }\r\n  }\r\n\r\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\r\n    var htmlMode = CodeMirror.getMode(config, {\r\n      name: \"xml\",\r\n      htmlMode: true,\r\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\r\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\r\n    });\r\n\r\n    var tags = {};\r\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\r\n    addTags(defaultTags, tags);\r\n    if (configTags) addTags(configTags, tags);\r\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\r\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\r\n\r\n    function html(stream, state) {\r\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\r\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\r\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\r\n          tags.hasOwnProperty(tagName)) {\r\n        state.inTag = tagName + \" \"\r\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\r\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\r\n        state.inTag = null\r\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2])\r\n        var mode = CodeMirror.getMode(config, modeSpec)\r\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\r\n        state.token = function (stream, state) {\r\n          if (stream.match(endTagA, false)) {\r\n            state.token = html;\r\n            state.localState = state.localMode = null;\r\n            return null;\r\n          }\r\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\r\n        };\r\n        state.localMode = mode;\r\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\", \"\"));\r\n      } else if (state.inTag) {\r\n        state.inTag += stream.current()\r\n        if (stream.eol()) state.inTag += \" \"\r\n      }\r\n      return style;\r\n    };\r\n\r\n    return {\r\n      startState: function () {\r\n        var state = CodeMirror.startState(htmlMode);\r\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\r\n      },\r\n\r\n      copyState: function (state) {\r\n        var local;\r\n        if (state.localState) {\r\n          local = CodeMirror.copyState(state.localMode, state.localState);\r\n        }\r\n        return {token: state.token, inTag: state.inTag,\r\n                localMode: state.localMode, localState: local,\r\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\r\n      },\r\n\r\n      token: function (stream, state) {\r\n        return state.token(stream, state);\r\n      },\r\n\r\n      indent: function (state, textAfter, line) {\r\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\r\n          return htmlMode.indent(state.htmlState, textAfter, line);\r\n        else if (state.localMode.indent)\r\n          return state.localMode.indent(state.localState, textAfter, line);\r\n        else\r\n          return CodeMirror.Pass;\r\n      },\r\n\r\n      innerMode: function (state) {\r\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\r\n      }\r\n    };\r\n  }, \"xml\", \"javascript\", \"css\");\r\n\r\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/mode/meta',[\"../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.modeInfo = [\r\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\r\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-encrypted\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"asc\", \"pgp\", \"sig\"]},\r\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\r\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\r\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\r\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\", \"ino\"]},\r\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\r\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\r\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\r\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\", \"cljc\", \"cljx\"]},\r\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\r\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\r\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\r\n    {name: \"CoffeeScript\", mimes: [\"application/vnd.coffeescript\", \"text/coffeescript\", \"text/x-coffeescript\"], mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\r\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\r\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\r\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\r\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\r\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\r\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\r\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\r\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\r\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\r\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\r\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\r\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\r\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\r\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\r\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\r\n    {name: \"edn\", mime: \"application/edn\", mode: \"clojure\", ext: [\"edn\"]},\r\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\r\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\r\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\r\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\r\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\r\n    {name: \"Esper\", mime: \"text/x-esper\", mode: \"sql\"},\r\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\r\n    {name: \"FCL\", mime: \"text/x-fcl\", mode: \"fcl\"},\r\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\r\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\", \"f95\"]},\r\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\r\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\r\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\r\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\r\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\r\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\", \"gradle\"], file: /^Jenkinsfile$/},\r\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\r\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\r\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\r\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\r\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\r\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\r\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\", \"handlebars\", \"hbs\"], alias: [\"xhtml\"]},\r\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\r\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\r\n    {name: \"Pug\", mime: \"text/x-pug\", mode: \"pug\", ext: [\"jade\", \"pug\"], alias: [\"jade\"]},\r\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\r\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\r\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\r\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\r\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\r\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\r\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\r\n    {name: \"Jinja2\", mime: \"text/jinja2\", mode: \"jinja2\", ext: [\"j2\", \"jinja\", \"jinja2\"]},\r\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\r\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\r\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\r\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\r\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\r\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\r\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\r\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\r\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\r\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\r\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\", ext: [\"mps\"]},\r\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\r\n    {name: \"mbox\", mime: \"application/mbox\", mode: \"mbox\", ext: [\"mbox\"]},\r\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\r\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\r\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\r\n    {name: \"NTriples\", mimes: [\"application/n-triples\", \"application/n-quads\", \"text/n-triples\"],\r\n     mode: \"ntriples\", ext: [\"nt\", \"nq\"]},\r\n    {name: \"Objective-C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"], alias: [\"objective-c\", \"objc\"]},\r\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\r\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\r\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\r\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\r\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\r\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\r\n    {name: \"PHP\", mimes: [\"text/x-php\", \"application/x-httpd-php\", \"application/x-httpd-php-open\"], mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"phtml\"]},\r\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\r\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\r\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\r\n    {name: \"PowerShell\", mime: \"application/x-powershell\", mode: \"powershell\", ext: [\"ps1\", \"psd1\", \"psm1\"]},\r\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\r\n    {name: \"ProtoBuf\", mime: \"text/x-protobuf\", mode: \"protobuf\", ext: [\"proto\"]},\r\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"], file: /^(BUCK|BUILD)$/},\r\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\r\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\r\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\", \"R\"], alias: [\"rscript\"]},\r\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\r\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\r\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\r\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\r\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\r\n    {name: \"SAS\", mime: \"text/x-sas\", mode: \"sas\", ext: [\"sas\"]},\r\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\r\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\r\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\r\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\r\n    {name: \"Shell\", mimes: [\"text/x-sh\", \"application/x-sh\"], mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\r\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\r\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\r\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\r\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\r\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\r\n    {name: \"SML\", mime: \"text/x-sml\", mode: \"mllike\", ext: [\"sml\", \"sig\", \"fun\", \"smackspec\"]},\r\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\r\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\r\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\r\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\r\n    {name: \"SQLite\", mime: \"text/x-sqlite\", mode: \"sql\"},\r\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\r\n    {name: \"Stylus\", mime: \"text/x-styl\", mode: \"stylus\", ext: [\"styl\"]},\r\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\r\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\r\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\", \"tex\"], alias: [\"tex\"]},\r\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\", \"sv\", \"svh\"]},\r\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\r\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\r\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\r\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\r\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\r\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\r\n    {name: \"troff\", mime: \"text/troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\r\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\r\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\r\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\r\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\r\n    {name: \"TypeScript-JSX\", mime: \"text/typescript-jsx\", mode: \"jsx\", ext: [\"tsx\"], alias: [\"tsx\"]},\r\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\r\n    {name: \"Web IDL\", mime: \"text/x-webidl\", mode: \"webidl\", ext: [\"webidl\"]},\r\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\r\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\r\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\r\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\r\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\r\n    {name: \"Vue.js Component\", mimes: [\"script/x-vue\", \"text/x-vue\"], mode: \"vue\", ext: [\"vue\"]},\r\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\r\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\r\n    {name: \"Yacas\", mime: \"text/x-yacas\", mode: \"yacas\", ext: [\"ys\"]},\r\n    {name: \"YAML\", mimes: [\"text/x-yaml\", \"text/yaml\"], mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\r\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\r\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\r\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\r\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\r\n  ];\r\n  // Ensure all modes have a mime property for backwards compatibility\r\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n    var info = CodeMirror.modeInfo[i];\r\n    if (info.mimes) info.mime = info.mimes[0];\r\n  }\r\n\r\n  CodeMirror.findModeByMIME = function(mime) {\r\n    mime = mime.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.mime == mime) return info;\r\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\r\n        if (info.mimes[j] == mime) return info;\r\n    }\r\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\")\r\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\")\r\n  };\r\n\r\n  CodeMirror.findModeByExtension = function(ext) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\r\n        if (info.ext[j] == ext) return info;\r\n    }\r\n  };\r\n\r\n  CodeMirror.findModeByFileName = function(filename) {\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.file && info.file.test(filename)) return info;\r\n    }\r\n    var dot = filename.lastIndexOf(\".\");\r\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\r\n    if (ext) return CodeMirror.findModeByExtension(ext);\r\n  };\r\n\r\n  CodeMirror.findModeByName = function(name) {\r\n    name = name.toLowerCase();\r\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\r\n      var info = CodeMirror.modeInfo[i];\r\n      if (info.name.toLowerCase() == name) return info;\r\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\r\n        if (info.alias[j].toLowerCase() == name) return info;\r\n    }\r\n  };\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/mode/markdown/markdown',[\r\n  \"../../CodeMirror\",\r\n  \"../xml/xml\",\r\n  \"../meta\"\r\n], function(CodeMirror) {\r\n\r\n\r\n\r\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\r\n\r\n  var htmlMode = CodeMirror.getMode(cmCfg, \"text/html\");\r\n  var htmlModeMissing = htmlMode.name == \"null\"\r\n\r\n  function getMode(name) {\r\n    if (CodeMirror.findModeByName) {\r\n      var found = CodeMirror.findModeByName(name);\r\n      if (found) name = found.mime || found.mimes[0];\r\n    }\r\n    var mode = CodeMirror.getMode(cmCfg, name);\r\n    return mode.name == \"null\" ? null : mode;\r\n  }\r\n\r\n  // Should characters that affect highlighting be highlighted separate?\r\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\r\n  if (modeCfg.highlightFormatting === undefined)\r\n    modeCfg.highlightFormatting = false;\r\n\r\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\r\n  // Excess `>` will emit `error` token.\r\n  if (modeCfg.maxBlockquoteDepth === undefined)\r\n    modeCfg.maxBlockquoteDepth = 0;\r\n\r\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\r\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\r\n\r\n  // Turn on strikethrough syntax\r\n  if (modeCfg.strikethrough === undefined)\r\n    modeCfg.strikethrough = false;\r\n\r\n  if (modeCfg.emoji === undefined)\r\n    modeCfg.emoji = false;\r\n\r\n  if (modeCfg.fencedCodeBlockHighlighting === undefined)\r\n    modeCfg.fencedCodeBlockHighlighting = true;\r\n\r\n  if (modeCfg.xml === undefined)\r\n    modeCfg.xml = true;\r\n\r\n  // Allow token types to be overridden by user-provided token types.\r\n  if (modeCfg.tokenTypeOverrides === undefined)\r\n    modeCfg.tokenTypeOverrides = {};\r\n\r\n  var tokenTypes = {\r\n    header: \"header\",\r\n    code: \"comment\",\r\n    quote: \"quote\",\r\n    list1: \"variable-2\",\r\n    list2: \"variable-3\",\r\n    list3: \"keyword\",\r\n    hr: \"hr\",\r\n    image: \"image\",\r\n    imageAltText: \"image-alt-text\",\r\n    imageMarker: \"image-marker\",\r\n    formatting: \"formatting\",\r\n    linkInline: \"link\",\r\n    linkEmail: \"link\",\r\n    linkText: \"link\",\r\n    linkHref: \"string\",\r\n    em: \"em\",\r\n    strong: \"strong\",\r\n    strikethrough: \"strikethrough\",\r\n    emoji: \"builtin\"\r\n  };\r\n\r\n  for (var tokenType in tokenTypes) {\r\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\r\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\r\n    }\r\n  }\r\n\r\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\r\n  ,   listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/\r\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/i // Must follow listRE\r\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\r\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\r\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~:]+/\r\n  ,   fencedCodeRE = /^(~~~+|```+)[ \\t]*([\\w+#-]*)[^\\n`]*$/\r\n  ,   linkDefRE = /^\\s*\\[[^\\]]+?\\]:.*$/ // naive link-definition\r\n  ,   punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/\r\n  ,   expandedTab = \"    \" // CommonMark specifies tab as 4 spaces\r\n\r\n  function switchInline(stream, state, f) {\r\n    state.f = state.inline = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function switchBlock(stream, state, f) {\r\n    state.f = state.block = f;\r\n    return f(stream, state);\r\n  }\r\n\r\n  function lineIsEmpty(line) {\r\n    return !line || !/\\S/.test(line.string)\r\n  }\r\n\r\n  // Blocks\r\n\r\n  function blankLine(state) {\r\n    // Reset linkTitle state\r\n    state.linkTitle = false;\r\n    state.linkHref = false;\r\n    state.linkText = false;\r\n    // Reset EM state\r\n    state.em = false;\r\n    // Reset STRONG state\r\n    state.strong = false;\r\n    // Reset strikethrough state\r\n    state.strikethrough = false;\r\n    // Reset state.quote\r\n    state.quote = 0;\r\n    // Reset state.indentedCode\r\n    state.indentedCode = false;\r\n    if (state.f == htmlBlock) {\r\n      var exit = htmlModeMissing\r\n      if (!exit) {\r\n        var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\r\n        exit = inner.mode.name == \"xml\" && inner.state.tagStart === null &&\r\n          (!inner.state.context && inner.state.tokenize.isInText)\r\n      }\r\n      if (exit) {\r\n        state.f = inlineNormal;\r\n        state.block = blockNormal;\r\n        state.htmlState = null;\r\n      }\r\n    }\r\n    // Reset state.trailingSpace\r\n    state.trailingSpace = 0;\r\n    state.trailingSpaceNewLine = false;\r\n    // Mark this line as blank\r\n    state.prevLine = state.thisLine\r\n    state.thisLine = {stream: null}\r\n    return null;\r\n  }\r\n\r\n  function blockNormal(stream, state) {\r\n    var firstTokenOnLine = stream.column() === state.indentation;\r\n    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);\r\n    var prevLineIsIndentedCode = state.indentedCode;\r\n    var prevLineIsHr = state.prevLine.hr;\r\n    var prevLineIsList = state.list !== false;\r\n    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;\r\n\r\n    state.indentedCode = false;\r\n\r\n    var lineIndentation = state.indentation;\r\n    // compute once per line (on first token)\r\n    if (state.indentationDiff === null) {\r\n      state.indentationDiff = state.indentation;\r\n      if (prevLineIsList) {\r\n        // Reset inline styles which shouldn't propagate aross list items\r\n        state.em = false;\r\n        state.strong = false;\r\n        state.code = false;\r\n        state.strikethrough = false;\r\n\r\n        state.list = null;\r\n        // While this list item's marker's indentation is less than the deepest\r\n        //  list item's content's indentation,pop the deepest list item\r\n        //  indentation off the stack, and update block indentation state\r\n        while (lineIndentation < state.listStack[state.listStack.length - 1]) {\r\n          state.listStack.pop();\r\n          if (state.listStack.length) {\r\n            state.indentation = state.listStack[state.listStack.length - 1];\r\n          // less than the first list's indent -> the line is no longer a list\r\n          } else {\r\n            state.list = false;\r\n          }\r\n        }\r\n        if (state.list !== false) {\r\n          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]\r\n        }\r\n      }\r\n    }\r\n\r\n    // not comprehensive (currently only for setext detection purposes)\r\n    var allowsInlineContinuation = (\r\n        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&\r\n        (!prevLineIsList || !prevLineIsIndentedCode) &&\r\n        !state.prevLine.fencedCodeEnd\r\n    );\r\n\r\n    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&\r\n      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);\r\n\r\n    var match = null;\r\n    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||\r\n         state.prevLine.header || prevLineLineIsEmpty)) {\r\n      stream.skipToEnd();\r\n      state.indentedCode = true;\r\n      return tokenTypes.code;\r\n    } else if (stream.eatSpace()) {\r\n      return null;\r\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\r\n      state.quote = 0;\r\n      state.header = match[1].length;\r\n      state.thisLine.header = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {\r\n      state.quote = firstTokenOnLine ? 1 : state.quote + 1;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\r\n      stream.eatSpace();\r\n      return getType(state);\r\n    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {\r\n      var listType = match[1] ? \"ol\" : \"ul\";\r\n\r\n      state.indentation = lineIndentation + stream.current().length;\r\n      state.list = true;\r\n      state.quote = 0;\r\n\r\n      // Add this list item's content's indentation to the stack\r\n      state.listStack.push(state.indentation);\r\n\r\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\r\n        state.taskList = true;\r\n      }\r\n      state.f = state.inline;\r\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\r\n      return getType(state);\r\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {\r\n      state.quote = 0;\r\n      state.fencedEndRE = new RegExp(match[1] + \"+ *$\");\r\n      // try switching mode\r\n      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);\r\n      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);\r\n      state.f = state.block = local;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      state.code = -1\r\n      return getType(state);\r\n    // SETEXT has lowest block-scope precedence after HR, so check it after\r\n    //  the others (code, blockquote, list...)\r\n    } else if (\r\n      // if setext set, indicates line after ---/===\r\n      state.setext || (\r\n        // line before ---/===\r\n        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&\r\n        !state.code && !isHr && !linkDefRE.test(stream.string) &&\r\n        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))\r\n      )\r\n    ) {\r\n      if ( !state.setext ) {\r\n        state.header = match[0].charAt(0) == '=' ? 1 : 2;\r\n        state.setext = state.header;\r\n      } else {\r\n        state.header = state.setext;\r\n        // has no effect on type so we can reset it now\r\n        state.setext = 0;\r\n        stream.skipToEnd();\r\n        if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      }\r\n      state.thisLine.header = true;\r\n      state.f = state.inline;\r\n      return getType(state);\r\n    } else if (isHr) {\r\n      stream.skipToEnd();\r\n      state.hr = true;\r\n      state.thisLine.hr = true;\r\n      return tokenTypes.hr;\r\n    } else if (stream.peek() === '[') {\r\n      return switchInline(stream, state, footnoteLink);\r\n    }\r\n\r\n    return switchInline(stream, state, state.inline);\r\n  }\r\n\r\n  function htmlBlock(stream, state) {\r\n    var style = htmlMode.token(stream, state.htmlState);\r\n    if (!htmlModeMissing) {\r\n      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\r\n      if ((inner.mode.name == \"xml\" && inner.state.tagStart === null &&\r\n           (!inner.state.context && inner.state.tokenize.isInText)) ||\r\n          (state.md_inside && stream.current().indexOf(\">\") > -1)) {\r\n        state.f = inlineNormal;\r\n        state.block = blockNormal;\r\n        state.htmlState = null;\r\n      }\r\n    }\r\n    return style;\r\n  }\r\n\r\n  function local(stream, state) {\r\n    var currListInd = state.listStack[state.listStack.length - 1] || 0;\r\n    var hasExitedList = state.indentation < currListInd;\r\n    var maxFencedEndInd = currListInd + 3;\r\n    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\r\n      var returnType;\r\n      if (!hasExitedList) returnType = getType(state)\r\n      state.localMode = state.localState = null;\r\n      state.block = blockNormal;\r\n      state.f = inlineNormal;\r\n      state.fencedEndRE = null;\r\n      state.code = 0\r\n      state.thisLine.fencedCodeEnd = true;\r\n      if (hasExitedList) return switchBlock(stream, state, state.block);\r\n      return returnType;\r\n    } else if (state.localMode) {\r\n      return state.localMode.token(stream, state.localState);\r\n    } else {\r\n      stream.skipToEnd();\r\n      return tokenTypes.code;\r\n    }\r\n  }\r\n\r\n  // Inline\r\n  function getType(state) {\r\n    var styles = [];\r\n\r\n    if (state.formatting) {\r\n      styles.push(tokenTypes.formatting);\r\n\r\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\r\n\r\n      for (var i = 0; i < state.formatting.length; i++) {\r\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\r\n\r\n        if (state.formatting[i] === \"header\") {\r\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\r\n        }\r\n\r\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\r\n        // Add `error` instead if the maximum blockquote nesting depth is passed\r\n        if (state.formatting[i] === \"quote\") {\r\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\r\n          } else {\r\n            styles.push(\"error\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (state.taskOpen) {\r\n      styles.push(\"meta\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n    if (state.taskClosed) {\r\n      styles.push(\"property\");\r\n      return styles.length ? styles.join(' ') : null;\r\n    }\r\n\r\n    if (state.linkHref) {\r\n      styles.push(tokenTypes.linkHref, \"url\");\r\n    } else { // Only apply inline styles to non-url text\r\n      if (state.strong) { styles.push(tokenTypes.strong); }\r\n      if (state.em) { styles.push(tokenTypes.em); }\r\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\r\n      if (state.emoji) { styles.push(tokenTypes.emoji); }\r\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\r\n      if (state.code) { styles.push(tokenTypes.code); }\r\n      if (state.image) { styles.push(tokenTypes.image); }\r\n      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, \"link\"); }\r\n      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }\r\n    }\r\n\r\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\r\n\r\n    if (state.quote) {\r\n      styles.push(tokenTypes.quote);\r\n\r\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\r\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\r\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\r\n      } else {\r\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\r\n      }\r\n    }\r\n\r\n    if (state.list !== false) {\r\n      var listMod = (state.listStack.length - 1) % 3;\r\n      if (!listMod) {\r\n        styles.push(tokenTypes.list1);\r\n      } else if (listMod === 1) {\r\n        styles.push(tokenTypes.list2);\r\n      } else {\r\n        styles.push(tokenTypes.list3);\r\n      }\r\n    }\r\n\r\n    if (state.trailingSpaceNewLine) {\r\n      styles.push(\"trailing-space-new-line\");\r\n    } else if (state.trailingSpace) {\r\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\r\n    }\r\n\r\n    return styles.length ? styles.join(' ') : null;\r\n  }\r\n\r\n  function handleText(stream, state) {\r\n    if (stream.match(textRE, true)) {\r\n      return getType(state);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  function inlineNormal(stream, state) {\r\n    var style = state.text(stream, state);\r\n    if (typeof style !== 'undefined')\r\n      return style;\r\n\r\n    if (state.list) { // List marker (*, +, -, 1., etc)\r\n      state.list = null;\r\n      return getType(state);\r\n    }\r\n\r\n    if (state.taskList) {\r\n      var taskOpen = stream.match(taskListRE, true)[1] === \" \";\r\n      if (taskOpen) state.taskOpen = true;\r\n      else state.taskClosed = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\r\n      state.taskList = false;\r\n      return getType(state);\r\n    }\r\n\r\n    state.taskOpen = false;\r\n    state.taskClosed = false;\r\n\r\n    if (state.header && stream.match(/^#+$/, true)) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\r\n      return getType(state);\r\n    }\r\n\r\n    var ch = stream.next();\r\n\r\n    // Matches link titles present on next line\r\n    if (state.linkTitle) {\r\n      state.linkTitle = false;\r\n      var matchCh = ch;\r\n      if (ch === '(') {\r\n        matchCh = ')';\r\n      }\r\n      matchCh = (matchCh+'').replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\r\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\r\n      if (stream.match(new RegExp(regex), true)) {\r\n        return tokenTypes.linkHref;\r\n      }\r\n    }\r\n\r\n    // If this block is changed, it may need to be updated in GFM mode\r\n    if (ch === '`') {\r\n      var previousFormatting = state.formatting;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\r\n      stream.eatWhile('`');\r\n      var count = stream.current().length\r\n      if (state.code == 0 && (!state.quote || count == 1)) {\r\n        state.code = count\r\n        return getType(state)\r\n      } else if (count == state.code) { // Must be exact\r\n        var t = getType(state)\r\n        state.code = 0\r\n        return t\r\n      } else {\r\n        state.formatting = previousFormatting\r\n        return getType(state)\r\n      }\r\n    } else if (state.code) {\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '\\\\') {\r\n      stream.next();\r\n      if (modeCfg.highlightFormatting) {\r\n        var type = getType(state);\r\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\r\n        return type ? type + \" \" + formattingEscape : formattingEscape;\r\n      }\r\n    }\r\n\r\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\r\n      state.imageMarker = true;\r\n      state.image = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === '[' && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\r\n      state.imageMarker = false;\r\n      state.imageAltText = true\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.imageAltText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\r\n      var type = getType(state);\r\n      state.imageAltText = false;\r\n      state.image = false;\r\n      state.inline = state.f = linkHref;\r\n      return type;\r\n    }\r\n\r\n    if (ch === '[' && !state.image) {\r\n      if (state.linkText && stream.match(/^.*?\\]/)) return getType(state)\r\n      state.linkText = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      return getType(state);\r\n    }\r\n\r\n    if (ch === ']' && state.linkText) {\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      state.linkText = false;\r\n      state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal\r\n      return type;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\r\n      state.f = state.inline = linkInline;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkEmail;\r\n    }\r\n\r\n    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|\\?|!\\[CDATA\\[|[a-z][a-z0-9-]*(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^>]+)?)*\\s*(?:>|$))/i, false)) {\r\n      var end = stream.string.indexOf(\">\", stream.pos);\r\n      if (end != -1) {\r\n        var atts = stream.string.substring(stream.start, end);\r\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\r\n      }\r\n      stream.backUp(1);\r\n      state.htmlState = CodeMirror.startState(htmlMode);\r\n      return switchBlock(stream, state, htmlBlock);\r\n    }\r\n\r\n    if (modeCfg.xml && ch === '<' && stream.match(/^\\/\\w*?>/)) {\r\n      state.md_inside = false;\r\n      return \"tag\";\r\n    } else if (ch === \"*\" || ch === \"_\") {\r\n      var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2)\r\n      while (len < 3 && stream.eat(ch)) len++\r\n      var after = stream.peek() || \" \"\r\n      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\r\n      var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before))\r\n      var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after))\r\n      var setEm = null, setStrong = null\r\n      if (len % 2) { // Em\r\n        if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setEm = true\r\n        else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setEm = false\r\n      }\r\n      if (len > 1) { // Strong\r\n        if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\r\n          setStrong = true\r\n        else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\r\n          setStrong = false\r\n      }\r\n      if (setStrong != null || setEm != null) {\r\n        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\"\r\n        if (setEm === true) state.em = ch\r\n        if (setStrong === true) state.strong = ch\r\n        var t = getType(state)\r\n        if (setEm === false) state.em = false\r\n        if (setStrong === false) state.strong = false\r\n        return t\r\n      }\r\n    } else if (ch === ' ') {\r\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\r\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n          return getType(state);\r\n        } else { // Not surrounded by spaces, back up pointer\r\n          stream.backUp(1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (modeCfg.strikethrough) {\r\n      if (ch === '~' && stream.eatWhile(ch)) {\r\n        if (state.strikethrough) {// Remove strikethrough\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          var t = getType(state);\r\n          state.strikethrough = false;\r\n          return t;\r\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\r\n          state.strikethrough = true;\r\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\r\n          return getType(state);\r\n        }\r\n      } else if (ch === ' ') {\r\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\r\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\r\n            return getType(state);\r\n          } else { // Not surrounded by spaces, back up pointer\r\n            stream.backUp(2);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (modeCfg.emoji && ch === \":\" && stream.match(/^(?:[a-z_\\d+][a-z_\\d+-]*|\\-[a-z_\\d+][a-z_\\d+-]*):/)) {\r\n      state.emoji = true;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"emoji\";\r\n      var retType = getType(state);\r\n      state.emoji = false;\r\n      return retType;\r\n    }\r\n\r\n    if (ch === ' ') {\r\n      if (stream.match(/^ +$/, false)) {\r\n        state.trailingSpace++;\r\n      } else if (state.trailingSpace) {\r\n        state.trailingSpaceNewLine = true;\r\n      }\r\n    }\r\n\r\n    return getType(state);\r\n  }\r\n\r\n  function linkInline(stream, state) {\r\n    var ch = stream.next();\r\n\r\n    if (ch === \">\") {\r\n      state.f = state.inline = inlineNormal;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var type = getType(state);\r\n      if (type){\r\n        type += \" \";\r\n      } else {\r\n        type = \"\";\r\n      }\r\n      return type + tokenTypes.linkInline;\r\n    }\r\n\r\n    stream.match(/^[^>]+/, true);\r\n\r\n    return tokenTypes.linkInline;\r\n  }\r\n\r\n  function linkHref(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    var ch = stream.next();\r\n    if (ch === '(' || ch === '[') {\r\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    }\r\n    return 'error';\r\n  }\r\n\r\n  var linkRE = {\r\n    \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\r\n    \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\r\n  }\r\n\r\n  function getLinkHrefInside(endChar) {\r\n    return function(stream, state) {\r\n      var ch = stream.next();\r\n\r\n      if (ch === endChar) {\r\n        state.f = state.inline = inlineNormal;\r\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\r\n        var returnState = getType(state);\r\n        state.linkHref = false;\r\n        return returnState;\r\n      }\r\n\r\n      stream.match(linkRE[endChar])\r\n      state.linkHref = true;\r\n      return getType(state);\r\n    };\r\n  }\r\n\r\n  function footnoteLink(stream, state) {\r\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\r\n      state.f = footnoteLinkInside;\r\n      stream.next(); // Consume [\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      state.linkText = true;\r\n      return getType(state);\r\n    }\r\n    return switchInline(stream, state, inlineNormal);\r\n  }\r\n\r\n  function footnoteLinkInside(stream, state) {\r\n    if (stream.match(/^\\]:/, true)) {\r\n      state.f = state.inline = footnoteUrl;\r\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\r\n      var returnType = getType(state);\r\n      state.linkText = false;\r\n      return returnType;\r\n    }\r\n\r\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\r\n\r\n    return tokenTypes.linkText;\r\n  }\r\n\r\n  function footnoteUrl(stream, state) {\r\n    // Check if space, and return NULL if so (to avoid marking the space)\r\n    if(stream.eatSpace()){\r\n      return null;\r\n    }\r\n    // Match URL\r\n    stream.match(/^[^\\s]+/, true);\r\n    // Check for link title\r\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\r\n      state.linkTitle = true;\r\n    } else { // More content on line, check if link title\r\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\r\n    }\r\n    state.f = state.inline = inlineNormal;\r\n    return tokenTypes.linkHref + \" url\";\r\n  }\r\n\r\n  var mode = {\r\n    startState: function() {\r\n      return {\r\n        f: blockNormal,\r\n\r\n        prevLine: {stream: null},\r\n        thisLine: {stream: null},\r\n\r\n        block: blockNormal,\r\n        htmlState: null,\r\n        indentation: 0,\r\n\r\n        inline: inlineNormal,\r\n        text: handleText,\r\n\r\n        formatting: false,\r\n        linkText: false,\r\n        linkHref: false,\r\n        linkTitle: false,\r\n        code: 0,\r\n        em: false,\r\n        strong: false,\r\n        header: 0,\r\n        setext: 0,\r\n        hr: false,\r\n        taskList: false,\r\n        list: false,\r\n        listStack: [],\r\n        quote: 0,\r\n        trailingSpace: 0,\r\n        trailingSpaceNewLine: false,\r\n        strikethrough: false,\r\n        emoji: false,\r\n        fencedEndRE: null\r\n      };\r\n    },\r\n\r\n    copyState: function(s) {\r\n      return {\r\n        f: s.f,\r\n\r\n        prevLine: s.prevLine,\r\n        thisLine: s.thisLine,\r\n\r\n        block: s.block,\r\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\r\n        indentation: s.indentation,\r\n\r\n        localMode: s.localMode,\r\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\r\n\r\n        inline: s.inline,\r\n        text: s.text,\r\n        formatting: false,\r\n        linkText: s.linkText,\r\n        linkTitle: s.linkTitle,\r\n        linkHref: s.linkHref,\r\n        code: s.code,\r\n        em: s.em,\r\n        strong: s.strong,\r\n        strikethrough: s.strikethrough,\r\n        emoji: s.emoji,\r\n        header: s.header,\r\n        setext: s.setext,\r\n        hr: s.hr,\r\n        taskList: s.taskList,\r\n        list: s.list,\r\n        listStack: s.listStack.slice(0),\r\n        quote: s.quote,\r\n        indentedCode: s.indentedCode,\r\n        trailingSpace: s.trailingSpace,\r\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\r\n        md_inside: s.md_inside,\r\n        fencedEndRE: s.fencedEndRE\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n\r\n      // Reset state.formatting\r\n      state.formatting = false;\r\n\r\n      if (stream != state.thisLine.stream) {\r\n        state.header = 0;\r\n        state.hr = false;\r\n\r\n        if (stream.match(/^\\s*$/, true)) {\r\n          blankLine(state);\r\n          return null;\r\n        }\r\n\r\n        state.prevLine = state.thisLine\r\n        state.thisLine = {stream: stream}\r\n\r\n        // Reset state.taskList\r\n        state.taskList = false;\r\n\r\n        // Reset state.trailingSpace\r\n        state.trailingSpace = 0;\r\n        state.trailingSpaceNewLine = false;\r\n\r\n        if (!state.localState) {\r\n          state.f = state.block;\r\n          if (state.f != htmlBlock) {\r\n            var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, expandedTab).length;\r\n            state.indentation = indentation;\r\n            state.indentationDiff = null;\r\n            if (indentation > 0) return null;\r\n          }\r\n        }\r\n      }\r\n      return state.f(stream, state);\r\n    },\r\n\r\n    innerMode: function(state) {\r\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\r\n      if (state.localState) return {state: state.localState, mode: state.localMode};\r\n      return {state: state, mode: mode};\r\n    },\r\n\r\n    indent: function(state, textAfter, line) {\r\n      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)\r\n      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)\r\n      return CodeMirror.Pass\r\n    },\r\n\r\n    blankLine: blankLine,\r\n\r\n    getType: getType,\r\n\r\n    blockCommentStart: \"<!--\",\r\n    blockCommentEnd: \"-->\",\r\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\r\n    fold: \"markdown\"\r\n  };\r\n  return mode;\r\n}, \"xml\");\r\n\r\nCodeMirror.defineMIME(\"text/markdown\", \"markdown\");\r\n\r\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\ndefine('skylark-codemirror/addon/comment/comment',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var noOptions = {};\r\n  var nonWS = /[^\\s\\u00a0]/;\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  function firstNonWS(str) {\r\n    var found = str.search(nonWS);\r\n    return found == -1 ? 0 : found;\r\n  }\r\n\r\n  CodeMirror.commands.toggleComment = function(cm) {\r\n    cm.toggleComment();\r\n  };\r\n\r\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\r\n    if (!options) options = noOptions;\r\n    var cm = this;\r\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\r\n    for (var i = ranges.length - 1; i >= 0; i--) {\r\n      var from = ranges[i].from(), to = ranges[i].to();\r\n      if (from.line >= minLine) continue;\r\n      if (to.line >= minLine) to = Pos(minLine, 0);\r\n      minLine = from.line;\r\n      if (mode == null) {\r\n        if (cm.uncomment(from, to, options)) mode = \"un\";\r\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\r\n      } else if (mode == \"un\") {\r\n        cm.uncomment(from, to, options);\r\n      } else {\r\n        cm.lineComment(from, to, options);\r\n      }\r\n    }\r\n  });\r\n\r\n  // Rough heuristic to try and detect lines that are part of multi-line string\r\n  function probablyInsideString(cm, pos, line) {\r\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\r\n  }\r\n\r\n  function getMode(cm, pos) {\r\n    var mode = cm.getMode()\r\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\r\n    if (!options) options = noOptions;\r\n    var self = this, mode = getMode(self, from);\r\n    var firstLine = self.getLine(from.line);\r\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\r\n\r\n    var commentString = options.lineComment || mode.lineComment;\r\n    if (!commentString) {\r\n      if (options.blockCommentStart || mode.blockCommentStart) {\r\n        options.fullLines = true;\r\n        self.blockComment(from, to, options);\r\n      }\r\n      return;\r\n    }\r\n\r\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\r\n    var pad = options.padding == null ? \" \" : options.padding;\r\n    var blankLines = options.commentBlankLines || from.line == to.line;\r\n\r\n    self.operation(function() {\r\n      if (options.indent) {\r\n        var baseString = null;\r\n        for (var i = from.line; i < end; ++i) {\r\n          var line = self.getLine(i);\r\n          var whitespace = line.slice(0, firstNonWS(line));\r\n          if (baseString == null || baseString.length > whitespace.length) {\r\n            baseString = whitespace;\r\n          }\r\n        }\r\n        for (var i = from.line; i < end; ++i) {\r\n          var line = self.getLine(i), cut = baseString.length;\r\n          if (!blankLines && !nonWS.test(line)) continue;\r\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\r\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\r\n        }\r\n      } else {\r\n        for (var i = from.line; i < end; ++i) {\r\n          if (blankLines || nonWS.test(self.getLine(i)))\r\n            self.replaceRange(commentString + pad, Pos(i, 0));\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\r\n    if (!options) options = noOptions;\r\n    var self = this, mode = getMode(self, from);\r\n    var startString = options.blockCommentStart || mode.blockCommentStart;\r\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\r\n    if (!startString || !endString) {\r\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\r\n        self.lineComment(from, to, options);\r\n      return;\r\n    }\r\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\r\n\r\n    var end = Math.min(to.line, self.lastLine());\r\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\r\n\r\n    var pad = options.padding == null ? \" \" : options.padding;\r\n    if (from.line > end) return;\r\n\r\n    self.operation(function() {\r\n      if (options.fullLines != false) {\r\n        var lastLineHasText = nonWS.test(self.getLine(end));\r\n        self.replaceRange(pad + endString, Pos(end));\r\n        self.replaceRange(startString + pad, Pos(from.line, 0));\r\n        var lead = options.blockCommentLead || mode.blockCommentLead;\r\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\r\n          if (i != end || lastLineHasText)\r\n            self.replaceRange(lead + pad, Pos(i, 0));\r\n      } else {\r\n        self.replaceRange(endString, to);\r\n        self.replaceRange(startString, from);\r\n      }\r\n    });\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\r\n    if (!options) options = noOptions;\r\n    var self = this, mode = getMode(self, from);\r\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\r\n\r\n    // Try finding line comments\r\n    var lineString = options.lineComment || mode.lineComment, lines = [];\r\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\r\n    lineComment: {\r\n      if (!lineString) break lineComment;\r\n      for (var i = start; i <= end; ++i) {\r\n        var line = self.getLine(i);\r\n        var found = line.indexOf(lineString);\r\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\r\n        if (found == -1 && nonWS.test(line)) break lineComment;\r\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\r\n        lines.push(line);\r\n      }\r\n      self.operation(function() {\r\n        for (var i = start; i <= end; ++i) {\r\n          var line = lines[i - start];\r\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\r\n          if (pos < 0) continue;\r\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\r\n          didSomething = true;\r\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\r\n        }\r\n      });\r\n      if (didSomething) return true;\r\n    }\r\n\r\n    // Try block comments\r\n    var startString = options.blockCommentStart || mode.blockCommentStart;\r\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\r\n    if (!startString || !endString) return false;\r\n    var lead = options.blockCommentLead || mode.blockCommentLead;\r\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\r\n    if (open == -1) return false\r\n    var endLine = end == start ? startLine : self.getLine(end)\r\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\r\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\r\n    if (close == -1 ||\r\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\r\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\r\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\r\n      return false;\r\n\r\n    // Avoid killing block comments completely outside the selection.\r\n    // Positions of the last startString before the start of the selection, and the first endString after it.\r\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\r\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\r\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\r\n    // Positions of the first endString after the end of the selection, and the last startString before it.\r\n    firstEnd = endLine.indexOf(endString, to.ch);\r\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\r\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\r\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\r\n\r\n    self.operation(function() {\r\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\r\n                        Pos(end, close + endString.length));\r\n      var openEnd = open + startString.length;\r\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\r\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\r\n      if (lead) for (var i = start + 1; i <= end; ++i) {\r\n        var line = self.getLine(i), found = line.indexOf(lead);\r\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\r\n        var foundEnd = found + lead.length;\r\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\r\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\r\n      }\r\n    });\r\n    return true;\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/selection/active-line',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n  var WRAP_CLASS = \"CodeMirror-activeline\";\r\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\r\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\r\n\r\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\r\n    var prev = old == CodeMirror.Init ? false : old;\r\n    if (val == prev) return\r\n    if (prev) {\r\n      cm.off(\"beforeSelectionChange\", selectionChange);\r\n      clearActiveLines(cm);\r\n      delete cm.state.activeLines;\r\n    }\r\n    if (val) {\r\n      cm.state.activeLines = [];\r\n      updateActiveLines(cm, cm.listSelections());\r\n      cm.on(\"beforeSelectionChange\", selectionChange);\r\n    }\r\n  });\r\n\r\n  function clearActiveLines(cm) {\r\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\r\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\r\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\r\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\r\n    }\r\n  }\r\n\r\n  function sameArray(a, b) {\r\n    if (a.length != b.length) return false;\r\n    for (var i = 0; i < a.length; i++)\r\n      if (a[i] != b[i]) return false;\r\n    return true;\r\n  }\r\n\r\n  function updateActiveLines(cm, ranges) {\r\n    var active = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i];\r\n      var option = cm.getOption(\"styleActiveLine\");\r\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\r\n        continue\r\n      var line = cm.getLineHandleVisualStart(range.head.line);\r\n      if (active[active.length - 1] != line) active.push(line);\r\n    }\r\n    if (sameArray(cm.state.activeLines, active)) return;\r\n    cm.operation(function() {\r\n      clearActiveLines(cm);\r\n      for (var i = 0; i < active.length; i++) {\r\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\r\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\r\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\r\n      }\r\n      cm.state.activeLines = active;\r\n    });\r\n  }\r\n\r\n  function selectionChange(cm, sel) {\r\n    updateActiveLines(cm, sel.ranges);\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/foldcode',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  function doFold(cm, pos, options, force) {\r\n    if (options && options.call) {\r\n      var finder = options;\r\n      options = null;\r\n    } else {\r\n      var finder = getOption(cm, options, \"rangeFinder\");\r\n    }\r\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\r\n    var minSize = getOption(cm, options, \"minFoldSize\");\r\n\r\n    function getRange(allowFolded) {\r\n      var range = finder(cm, pos);\r\n      if (!range || range.to.line - range.from.line < minSize) return null;\r\n      var marks = cm.findMarksAt(range.from);\r\n      for (var i = 0; i < marks.length; ++i) {\r\n        if (marks[i].__isFold && force !== \"fold\") {\r\n          if (!allowFolded) return null;\r\n          range.cleared = true;\r\n          marks[i].clear();\r\n        }\r\n      }\r\n      return range;\r\n    }\r\n\r\n    var range = getRange(true);\r\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\r\n      pos = CodeMirror.Pos(pos.line - 1, 0);\r\n      range = getRange(false);\r\n    }\r\n    if (!range || range.cleared || force === \"unfold\") return;\r\n\r\n    var myWidget = makeWidget(cm, options);\r\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\r\n      myRange.clear();\r\n      CodeMirror.e_preventDefault(e);\r\n    });\r\n    var myRange = cm.markText(range.from, range.to, {\r\n      replacedWith: myWidget,\r\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\r\n      __isFold: true\r\n    });\r\n    myRange.on(\"clear\", function(from, to) {\r\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\r\n    });\r\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\r\n  }\r\n\r\n  function makeWidget(cm, options) {\r\n    var widget = getOption(cm, options, \"widget\");\r\n    if (typeof widget == \"string\") {\r\n      var text = document.createTextNode(widget);\r\n      widget = document.createElement(\"span\");\r\n      widget.appendChild(text);\r\n      widget.className = \"CodeMirror-foldmarker\";\r\n    } else if (widget) {\r\n      widget = widget.cloneNode(true)\r\n    }\r\n    return widget;\r\n  }\r\n\r\n  // Clumsy backwards-compatible interface\r\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\r\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\r\n  };\r\n\r\n  // New-style interface\r\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\r\n    doFold(this, pos, options, force);\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\r\n    var marks = this.findMarksAt(pos);\r\n    for (var i = 0; i < marks.length; ++i)\r\n      if (marks[i].__isFold) return true;\r\n  });\r\n\r\n  CodeMirror.commands.toggleFold = function(cm) {\r\n    cm.foldCode(cm.getCursor());\r\n  };\r\n  CodeMirror.commands.fold = function(cm) {\r\n    cm.foldCode(cm.getCursor(), null, \"fold\");\r\n  };\r\n  CodeMirror.commands.unfold = function(cm) {\r\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\r\n  };\r\n  CodeMirror.commands.foldAll = function(cm) {\r\n    cm.operation(function() {\r\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\r\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\r\n    });\r\n  };\r\n  CodeMirror.commands.unfoldAll = function(cm) {\r\n    cm.operation(function() {\r\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\r\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\r\n    });\r\n  };\r\n\r\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\r\n    var funcs = Array.prototype.slice.call(arguments, 0);\r\n    return function(cm, start) {\r\n      for (var i = 0; i < funcs.length; ++i) {\r\n        var found = funcs[i](cm, start);\r\n        if (found) return found;\r\n      }\r\n    };\r\n  });\r\n\r\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\r\n    var helpers = cm.getHelpers(start, \"fold\");\r\n    for (var i = 0; i < helpers.length; i++) {\r\n      var cur = helpers[i](cm, start);\r\n      if (cur) return cur;\r\n    }\r\n  });\r\n\r\n  var defaultOptions = {\r\n    rangeFinder: CodeMirror.fold.auto,\r\n    widget: \"\\u2194\",\r\n    minFoldSize: 0,\r\n    scanUp: false,\r\n    clearOnEnter: true\r\n  };\r\n\r\n  CodeMirror.defineOption(\"foldOptions\", null);\r\n\r\n  function getOption(cm, options, name) {\r\n    if (options && options[name] !== undefined)\r\n      return options[name];\r\n    var editorOptions = cm.options.foldOptions;\r\n    if (editorOptions && editorOptions[name] !== undefined)\r\n      return editorOptions[name];\r\n    return defaultOptions[name];\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\r\n    return getOption(this, options, name);\r\n  });\r\n});\r\n\ndefine('skylark-codemirror/addon/fold/foldgutter',[\r\n  \"../../CodeMirror\", \r\n  \"./foldcode\"\r\n],function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\r\n      cm.state.foldGutter = null;\r\n      cm.off(\"gutterClick\", onGutterClick);\r\n      cm.off(\"change\", onChange);\r\n      cm.off(\"viewportChange\", onViewportChange);\r\n      cm.off(\"fold\", onFold);\r\n      cm.off(\"unfold\", onFold);\r\n      cm.off(\"swapDoc\", onChange);\r\n    }\r\n    if (val) {\r\n      cm.state.foldGutter = new State(parseOptions(val));\r\n      updateInViewport(cm);\r\n      cm.on(\"gutterClick\", onGutterClick);\r\n      cm.on(\"change\", onChange);\r\n      cm.on(\"viewportChange\", onViewportChange);\r\n      cm.on(\"fold\", onFold);\r\n      cm.on(\"unfold\", onFold);\r\n      cm.on(\"swapDoc\", onChange);\r\n    }\r\n  });\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  function State(options) {\r\n    this.options = options;\r\n    this.from = this.to = 0;\r\n  }\r\n\r\n  function parseOptions(opts) {\r\n    if (opts === true) opts = {};\r\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\r\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\r\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\r\n    return opts;\r\n  }\r\n\r\n  function isFolded(cm, line) {\r\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\r\n    for (var i = 0; i < marks.length; ++i)\r\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\r\n  }\r\n\r\n  function marker(spec) {\r\n    if (typeof spec == \"string\") {\r\n      var elt = document.createElement(\"div\");\r\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\r\n      return elt;\r\n    } else {\r\n      return spec.cloneNode(true);\r\n    }\r\n  }\r\n\r\n  function updateFoldInfo(cm, from, to) {\r\n    var opts = cm.state.foldGutter.options, cur = from;\r\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\r\n    var func = cm.foldOption(opts, \"rangeFinder\");\r\n    cm.eachLine(from, to, function(line) {\r\n      var mark = null;\r\n      if (isFolded(cm, cur)) {\r\n        mark = marker(opts.indicatorFolded);\r\n      } else {\r\n        var pos = Pos(cur, 0);\r\n        var range = func && func(cm, pos);\r\n        if (range && range.to.line - range.from.line >= minSize)\r\n          mark = marker(opts.indicatorOpen);\r\n      }\r\n      cm.setGutterMarker(line, opts.gutter, mark);\r\n      ++cur;\r\n    });\r\n  }\r\n\r\n  function updateInViewport(cm) {\r\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\r\n    if (!state) return;\r\n    cm.operation(function() {\r\n      updateFoldInfo(cm, vp.from, vp.to);\r\n    });\r\n    state.from = vp.from; state.to = vp.to;\r\n  }\r\n\r\n  function onGutterClick(cm, line, gutter) {\r\n    var state = cm.state.foldGutter;\r\n    if (!state) return;\r\n    var opts = state.options;\r\n    if (gutter != opts.gutter) return;\r\n    var folded = isFolded(cm, line);\r\n    if (folded) folded.clear();\r\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\r\n  }\r\n\r\n  function onChange(cm) {\r\n    var state = cm.state.foldGutter;\r\n    if (!state) return;\r\n    var opts = state.options;\r\n    state.from = state.to = 0;\r\n    clearTimeout(state.changeUpdate);\r\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\r\n  }\r\n\r\n  function onViewportChange(cm) {\r\n    var state = cm.state.foldGutter;\r\n    if (!state) return;\r\n    var opts = state.options;\r\n    clearTimeout(state.changeUpdate);\r\n    state.changeUpdate = setTimeout(function() {\r\n      var vp = cm.getViewport();\r\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\r\n        updateInViewport(cm);\r\n      } else {\r\n        cm.operation(function() {\r\n          if (vp.from < state.from) {\r\n            updateFoldInfo(cm, vp.from, state.from);\r\n            state.from = vp.from;\r\n          }\r\n          if (vp.to > state.to) {\r\n            updateFoldInfo(cm, state.to, vp.to);\r\n            state.to = vp.to;\r\n          }\r\n        });\r\n      }\r\n    }, opts.updateViewportTimeSpan || 400);\r\n  }\r\n\r\n  function onFold(cm, from) {\r\n    var state = cm.state.foldGutter;\r\n    if (!state) return;\r\n    var line = from.line;\r\n    if (line >= state.from && line < state.to)\r\n      updateFoldInfo(cm, line, line + 1);\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/brace-fold',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\r\n  var line = start.line, lineText = cm.getLine(line);\r\n  var tokenType;\r\n\r\n  function findOpening(openCh) {\r\n    for (var at = start.ch, pass = 0;;) {\r\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\r\n      if (found == -1) {\r\n        if (pass == 1) break;\r\n        pass = 1;\r\n        at = lineText.length;\r\n        continue;\r\n      }\r\n      if (pass == 1 && found < start.ch) break;\r\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\r\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\r\n      at = found - 1;\r\n    }\r\n  }\r\n\r\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\r\n  if (startCh == null) {\r\n    startToken = \"[\", endToken = \"]\";\r\n    startCh = findOpening(\"[\");\r\n  }\r\n\r\n  if (startCh == null) return;\r\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\r\n  outer: for (var i = line; i <= lastLine; ++i) {\r\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\r\n    for (;;) {\r\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\r\n      if (nextOpen < 0) nextOpen = text.length;\r\n      if (nextClose < 0) nextClose = text.length;\r\n      pos = Math.min(nextOpen, nextClose);\r\n      if (pos == text.length) break;\r\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\r\n        if (pos == nextOpen) ++count;\r\n        else if (!--count) { end = i; endCh = pos; break outer; }\r\n      }\r\n      ++pos;\r\n    }\r\n  }\r\n  if (end == null || line == end) return;\r\n  return {from: CodeMirror.Pos(line, startCh),\r\n          to: CodeMirror.Pos(end, endCh)};\r\n});\r\n\r\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\r\n  function hasImport(line) {\r\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\r\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\r\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\r\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\r\n    // Now find closing semicolon, return its position\r\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\r\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\r\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\r\n    }\r\n  }\r\n\r\n  var startLine = start.line, has = hasImport(startLine), prev;\r\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\r\n    return null;\r\n  for (var end = has.end;;) {\r\n    var next = hasImport(end.line + 1);\r\n    if (next == null) break;\r\n    end = next.end;\r\n  }\r\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\r\n});\r\n\r\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\r\n  function hasInclude(line) {\r\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\r\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\r\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\r\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\r\n  }\r\n\r\n  var startLine = start.line, has = hasInclude(startLine);\r\n  if (has == null || hasInclude(startLine - 1) != null) return null;\r\n  for (var end = startLine;;) {\r\n    var next = hasInclude(end + 1);\r\n    if (next == null) break;\r\n    ++end;\r\n  }\r\n  return {from: CodeMirror.Pos(startLine, has + 1),\r\n          to: cm.clipPos(CodeMirror.Pos(end))};\r\n});\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/xml-fold',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var Pos = CodeMirror.Pos;\r\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\r\n\r\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\r\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\r\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\r\n\r\n  function Iter(cm, line, ch, range) {\r\n    this.line = line; this.ch = ch;\r\n    this.cm = cm; this.text = cm.getLine(line);\r\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\r\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\r\n  }\r\n\r\n  function tagAt(iter, ch) {\r\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\r\n    return type && /\\btag\\b/.test(type);\r\n  }\r\n\r\n  function nextLine(iter) {\r\n    if (iter.line >= iter.max) return;\r\n    iter.ch = 0;\r\n    iter.text = iter.cm.getLine(++iter.line);\r\n    return true;\r\n  }\r\n  function prevLine(iter) {\r\n    if (iter.line <= iter.min) return;\r\n    iter.text = iter.cm.getLine(--iter.line);\r\n    iter.ch = iter.text.length;\r\n    return true;\r\n  }\r\n\r\n  function toTagEnd(iter) {\r\n    for (;;) {\r\n      var gt = iter.text.indexOf(\">\", iter.ch);\r\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\r\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\r\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\r\n      iter.ch = gt + 1;\r\n      return selfClose ? \"selfClose\" : \"regular\";\r\n    }\r\n  }\r\n  function toTagStart(iter) {\r\n    for (;;) {\r\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\r\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\r\n      xmlTagStart.lastIndex = lt;\r\n      iter.ch = lt;\r\n      var match = xmlTagStart.exec(iter.text);\r\n      if (match && match.index == lt) return match;\r\n    }\r\n  }\r\n\r\n  function toNextTag(iter) {\r\n    for (;;) {\r\n      xmlTagStart.lastIndex = iter.ch;\r\n      var found = xmlTagStart.exec(iter.text);\r\n      if (!found) { if (nextLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\r\n      iter.ch = found.index + found[0].length;\r\n      return found;\r\n    }\r\n  }\r\n  function toPrevTag(iter) {\r\n    for (;;) {\r\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\r\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\r\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\r\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\r\n      iter.ch = gt + 1;\r\n      return selfClose ? \"selfClose\" : \"regular\";\r\n    }\r\n  }\r\n\r\n  function findMatchingClose(iter, tag) {\r\n    var stack = [];\r\n    for (;;) {\r\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\r\n      if (!next || !(end = toTagEnd(iter))) return;\r\n      if (end == \"selfClose\") continue;\r\n      if (next[1]) { // closing tag\r\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\r\n          stack.length = i;\r\n          break;\r\n        }\r\n        if (i < 0 && (!tag || tag == next[2])) return {\r\n          tag: next[2],\r\n          from: Pos(startLine, startCh),\r\n          to: Pos(iter.line, iter.ch)\r\n        };\r\n      } else { // opening tag\r\n        stack.push(next[2]);\r\n      }\r\n    }\r\n  }\r\n  function findMatchingOpen(iter, tag) {\r\n    var stack = [];\r\n    for (;;) {\r\n      var prev = toPrevTag(iter);\r\n      if (!prev) return;\r\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\r\n      var endLine = iter.line, endCh = iter.ch;\r\n      var start = toTagStart(iter);\r\n      if (!start) return;\r\n      if (start[1]) { // closing tag\r\n        stack.push(start[2]);\r\n      } else { // opening tag\r\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\r\n          stack.length = i;\r\n          break;\r\n        }\r\n        if (i < 0 && (!tag || tag == start[2])) return {\r\n          tag: start[2],\r\n          from: Pos(iter.line, iter.ch),\r\n          to: Pos(endLine, endCh)\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\r\n    var iter = new Iter(cm, start.line, 0);\r\n    for (;;) {\r\n      var openTag = toNextTag(iter)\r\n      if (!openTag || iter.line != start.line) return\r\n      var end = toTagEnd(iter)\r\n      if (!end) return\r\n      if (!openTag[1] && end != \"selfClose\") {\r\n        var startPos = Pos(iter.line, iter.ch);\r\n        var endPos = findMatchingClose(iter, openTag[2]);\r\n        return endPos && cmp(endPos.from, startPos) > 0 ? {from: startPos, to: endPos.from} : null\r\n      }\r\n    }\r\n  });\r\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, range);\r\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\r\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\r\n    var start = end && toTagStart(iter);\r\n    if (!end || !start || cmp(iter, pos) > 0) return;\r\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\r\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\r\n\r\n    if (start[1]) { // closing tag\r\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\r\n    } else { // opening tag\r\n      iter = new Iter(cm, to.line, to.ch, range);\r\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\r\n    }\r\n  };\r\n\r\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, range);\r\n    for (;;) {\r\n      var open = findMatchingOpen(iter, tag);\r\n      if (!open) break;\r\n      var forward = new Iter(cm, pos.line, pos.ch, range);\r\n      var close = findMatchingClose(forward, open.tag);\r\n      if (close) return {open: open, close: close};\r\n    }\r\n  };\r\n\r\n  // Used by addon/edit/closetag.js\r\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\r\n    return findMatchingClose(iter, name);\r\n  };\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/indent-fold',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nfunction lineIndent(cm, lineNo) {\r\n  var text = cm.getLine(lineNo)\r\n  var spaceTo = text.search(/\\S/)\r\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\r\n    return -1\r\n  return CodeMirror.countColumn(text, null, cm.getOption(\"tabSize\"))\r\n}\r\n\r\nCodeMirror.registerHelper(\"fold\", \"indent\", function(cm, start) {\r\n  var myIndent = lineIndent(cm, start.line)\r\n  if (myIndent < 0) return\r\n  var lastLineInFold = null\r\n\r\n  // Go through lines until we find a line that definitely doesn't belong in\r\n  // the block we're folding, or to the end.\r\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\r\n    var indent = lineIndent(cm, i)\r\n    if (indent == -1) {\r\n    } else if (indent > myIndent) {\r\n      // Lines with a greater indent are considered part of the block.\r\n      lastLineInFold = i;\r\n    } else {\r\n      // If this line has non-space, non-comment content, and is\r\n      // indented less or equal to the start line, it is the start of\r\n      // another block.\r\n      break;\r\n    }\r\n  }\r\n  if (lastLineInFold) return {\r\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\r\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\r\n  };\r\n});\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/markdown-fold',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nCodeMirror.registerHelper(\"fold\", \"markdown\", function(cm, start) {\r\n  var maxDepth = 100;\r\n\r\n  function isHeader(lineNo) {\r\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\r\n    return tokentype && /\\bheader\\b/.test(tokentype);\r\n  }\r\n\r\n  function headerLevel(lineNo, line, nextLine) {\r\n    var match = line && line.match(/^#+/);\r\n    if (match && isHeader(lineNo)) return match[0].length;\r\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\r\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == \"=\" ? 1 : 2;\r\n    return maxDepth;\r\n  }\r\n\r\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\r\n  var level = headerLevel(start.line, firstLine, nextLine);\r\n  if (level === maxDepth) return undefined;\r\n\r\n  var lastLineNo = cm.lastLine();\r\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\r\n  while (end < lastLineNo) {\r\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\r\n    ++end;\r\n    nextLine = nextNextLine;\r\n    nextNextLine = cm.getLine(end + 2);\r\n  }\r\n\r\n  return {\r\n    from: CodeMirror.Pos(start.line, firstLine.length),\r\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\r\n  };\r\n});\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/fold/comment-fold',[\"../../CodeMirror\"], function(CodeMirror) {\r\n\r\n\r\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\r\n  return mode.blockCommentStart && mode.blockCommentEnd;\r\n}, function(cm, start) {\r\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\r\n  if (!startToken || !endToken) return;\r\n  var line = start.line, lineText = cm.getLine(line);\r\n\r\n  var startCh;\r\n  for (var at = start.ch, pass = 0;;) {\r\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\r\n    if (found == -1) {\r\n      if (pass == 1) return;\r\n      pass = 1;\r\n      at = lineText.length;\r\n      continue;\r\n    }\r\n    if (pass == 1 && found < start.ch) return;\r\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\r\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\r\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\r\n      startCh = found + startToken.length;\r\n      break;\r\n    }\r\n    at = found - 1;\r\n  }\r\n\r\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\r\n  outer: for (var i = line; i <= lastLine; ++i) {\r\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\r\n    for (;;) {\r\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\r\n      if (nextOpen < 0) nextOpen = text.length;\r\n      if (nextClose < 0) nextClose = text.length;\r\n      pos = Math.min(nextOpen, nextClose);\r\n      if (pos == text.length) break;\r\n      if (pos == nextOpen) ++depth;\r\n      else if (!--depth) { end = i; endCh = pos; break outer; }\r\n      ++pos;\r\n    }\r\n  }\r\n  if (end == null || line == end && endCh == startCh) return;\r\n  return {from: CodeMirror.Pos(line, startCh),\r\n          to: CodeMirror.Pos(end, endCh)};\r\n});\r\n\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/edit/matchbrackets',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\r\n    (document.documentMode == null || document.documentMode < 8);\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\r\n\r\n  function bracketRegex(config) {\r\n    return config && config.bracketRegex || /[(){}[\\]]/\r\n  }\r\n\r\n  function findMatchingBracket(cm, where, config) {\r\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\r\n    var afterCursor = config && config.afterCursor\r\n    if (afterCursor == null)\r\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\r\n    var re = bracketRegex(config)\r\n\r\n    // A cursor is defined as between two characters, but in in vim command mode\r\n    // (i.e. not insert mode), the cursor is visually represented as a\r\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\r\n    // from before or after the cursor.\r\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\r\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\r\n    if (!match) return null;\r\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\r\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\r\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\r\n\r\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\r\n    if (found == null) return null;\r\n    return {from: Pos(where.line, pos), to: found && found.pos,\r\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\r\n  }\r\n\r\n  // bracketRegex is used to specify which type of bracket to scan\r\n  // should be a regexp, e.g. /[[\\]]/\r\n  //\r\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\r\n  //\r\n  // Returns false when no bracket was found, null when it reached\r\n  // maxScanLines and gave up\r\n  function scanForBracket(cm, where, dir, style, config) {\r\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\r\n    var maxScanLines = (config && config.maxScanLines) || 1000;\r\n\r\n    var stack = [];\r\n    var re = bracketRegex(config)\r\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\r\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\r\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\r\n      var line = cm.getLine(lineNo);\r\n      if (!line) continue;\r\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\r\n      if (line.length > maxScanLen) continue;\r\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\r\n      for (; pos != end; pos += dir) {\r\n        var ch = line.charAt(pos);\r\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\r\n          var match = matching[ch];\r\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\r\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\r\n          else stack.pop();\r\n        }\r\n      }\r\n    }\r\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\r\n  }\r\n\r\n  function matchBrackets(cm, autoclear, config) {\r\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\r\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\r\n    var marks = [], ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\r\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\r\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\r\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\r\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\r\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\r\n      }\r\n    }\r\n\r\n    if (marks.length) {\r\n      // Kludge to work around the IE bug from issue #1193, where text\r\n      // input stops going to the textare whever this fires.\r\n      if (ie_lt8 && cm.state.focused) cm.focus();\r\n\r\n      var clear = function() {\r\n        cm.operation(function() {\r\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\r\n        });\r\n      };\r\n      if (autoclear) setTimeout(clear, 800);\r\n      else return clear;\r\n    }\r\n  }\r\n\r\n  function doMatchBrackets(cm) {\r\n    cm.operation(function() {\r\n      if (cm.state.matchBrackets.currentlyHighlighted) {\r\n        cm.state.matchBrackets.currentlyHighlighted();\r\n        cm.state.matchBrackets.currentlyHighlighted = null;\r\n      }\r\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\r\n    });\r\n  }\r\n\r\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      cm.off(\"cursorActivity\", doMatchBrackets);\r\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\r\n        cm.state.matchBrackets.currentlyHighlighted();\r\n        cm.state.matchBrackets.currentlyHighlighted = null;\r\n      }\r\n    }\r\n    if (val) {\r\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\r\n      cm.on(\"cursorActivity\", doMatchBrackets);\r\n    }\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\r\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\r\n    // Backwards-compatibility kludge\r\n    if (oldConfig || typeof config == \"boolean\") {\r\n      if (!oldConfig) {\r\n        config = config ? {strict: true} : null\r\n      } else {\r\n        oldConfig.strict = config\r\n        config = oldConfig\r\n      }\r\n    }\r\n    return findMatchingBracket(this, pos, config)\r\n  });\r\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\r\n    return scanForBracket(this, pos, dir, style, config);\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/edit/closebrackets',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  var defaults = {\r\n    pairs: \"()[]{}''\\\"\\\"\",\r\n    closeBefore: \")]}'\\\":;>\",\r\n    triples: \"\",\r\n    explode: \"[]{}\"\r\n  };\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      cm.removeKeyMap(keyMap);\r\n      cm.state.closeBrackets = null;\r\n    }\r\n    if (val) {\r\n      ensureBound(getOption(val, \"pairs\"))\r\n      cm.state.closeBrackets = val;\r\n      cm.addKeyMap(keyMap);\r\n    }\r\n  });\r\n\r\n  function getOption(conf, name) {\r\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\r\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\r\n    return defaults[name];\r\n  }\r\n\r\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\r\n  function ensureBound(chars) {\r\n    for (var i = 0; i < chars.length; i++) {\r\n      var ch = chars.charAt(i), key = \"'\" + ch + \"'\"\r\n      if (!keyMap[key]) keyMap[key] = handler(ch)\r\n    }\r\n  }\r\n  ensureBound(defaults.pairs + \"`\")\r\n\r\n  function handler(ch) {\r\n    return function(cm) { return handleChar(cm, ch); };\r\n  }\r\n\r\n  function getConfig(cm) {\r\n    var deflt = cm.state.closeBrackets;\r\n    if (!deflt || deflt.override) return deflt;\r\n    var mode = cm.getModeAt(cm.getCursor());\r\n    return mode.closeBrackets || deflt;\r\n  }\r\n\r\n  function handleBackspace(cm) {\r\n    var conf = getConfig(cm);\r\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\r\n\r\n    var pairs = getOption(conf, \"pairs\");\r\n    var ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) return CodeMirror.Pass;\r\n      var around = charsAround(cm, ranges[i].head);\r\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\r\n    }\r\n    for (var i = ranges.length - 1; i >= 0; i--) {\r\n      var cur = ranges[i].head;\r\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\r\n    }\r\n  }\r\n\r\n  function handleEnter(cm) {\r\n    var conf = getConfig(cm);\r\n    var explode = conf && getOption(conf, \"explode\");\r\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\r\n\r\n    var ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) return CodeMirror.Pass;\r\n      var around = charsAround(cm, ranges[i].head);\r\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\r\n    }\r\n    cm.operation(function() {\r\n      var linesep = cm.lineSeparator() || \"\\n\";\r\n      cm.replaceSelection(linesep + linesep, null);\r\n      cm.execCommand(\"goCharLeft\");\r\n      ranges = cm.listSelections();\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var line = ranges[i].head.line;\r\n        cm.indentLine(line, null, true);\r\n        cm.indentLine(line + 1, null, true);\r\n      }\r\n    });\r\n  }\r\n\r\n  function contractSelection(sel) {\r\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\r\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\r\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\r\n  }\r\n\r\n  function handleChar(cm, ch) {\r\n    var conf = getConfig(cm);\r\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\r\n\r\n    var pairs = getOption(conf, \"pairs\");\r\n    var pos = pairs.indexOf(ch);\r\n    if (pos == -1) return CodeMirror.Pass;\r\n\r\n    var closeBefore = getOption(conf,\"closeBefore\");\r\n\r\n    var triples = getOption(conf, \"triples\");\r\n\r\n    var identical = pairs.charAt(pos + 1) == ch;\r\n    var ranges = cm.listSelections();\r\n    var opening = pos % 2 == 0;\r\n\r\n    var type;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i], cur = range.head, curType;\r\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\r\n      if (opening && !range.empty()) {\r\n        curType = \"surround\";\r\n      } else if ((identical || !opening) && next == ch) {\r\n        if (identical && stringStartsAfter(cm, cur))\r\n          curType = \"both\";\r\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\r\n          curType = \"skipThree\";\r\n        else\r\n          curType = \"skip\";\r\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\r\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {\r\n        if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;\r\n        curType = \"addFour\";\r\n      } else if (identical) {\r\n        var prev = cur.ch == 0 ? \" \" : cm.getRange(Pos(cur.line, cur.ch - 1), cur)\r\n        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = \"both\";\r\n        else return CodeMirror.Pass;\r\n      } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {\r\n        curType = \"both\";\r\n      } else {\r\n        return CodeMirror.Pass;\r\n      }\r\n      if (!type) type = curType;\r\n      else if (type != curType) return CodeMirror.Pass;\r\n    }\r\n\r\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\r\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\r\n    cm.operation(function() {\r\n      if (type == \"skip\") {\r\n        cm.execCommand(\"goCharRight\");\r\n      } else if (type == \"skipThree\") {\r\n        for (var i = 0; i < 3; i++)\r\n          cm.execCommand(\"goCharRight\");\r\n      } else if (type == \"surround\") {\r\n        var sels = cm.getSelections();\r\n        for (var i = 0; i < sels.length; i++)\r\n          sels[i] = left + sels[i] + right;\r\n        cm.replaceSelections(sels, \"around\");\r\n        sels = cm.listSelections().slice();\r\n        for (var i = 0; i < sels.length; i++)\r\n          sels[i] = contractSelection(sels[i]);\r\n        cm.setSelections(sels);\r\n      } else if (type == \"both\") {\r\n        cm.replaceSelection(left + right, null);\r\n        cm.triggerElectric(left + right);\r\n        cm.execCommand(\"goCharLeft\");\r\n      } else if (type == \"addFour\") {\r\n        cm.replaceSelection(left + left + left + left, \"before\");\r\n        cm.execCommand(\"goCharRight\");\r\n      }\r\n    });\r\n  }\r\n\r\n  function charsAround(cm, pos) {\r\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\r\n                          Pos(pos.line, pos.ch + 1));\r\n    return str.length == 2 ? str : null;\r\n  }\r\n\r\n  function stringStartsAfter(cm, pos) {\r\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\r\n    return /\\bstring/.test(token.type) && token.start == pos.ch &&\r\n      (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)))\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/edit/trailingspace',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  CodeMirror.defineOption(\"showTrailingSpace\", false, function(cm, val, prev) {\r\n    if (prev == CodeMirror.Init) prev = false;\r\n    if (prev && !val)\r\n      cm.removeOverlay(\"trailingspace\");\r\n    else if (!prev && val)\r\n      cm.addOverlay({\r\n        token: function(stream) {\r\n          for (var l = stream.string.length, i = l; i && /\\s/.test(stream.string.charAt(i - 1)); --i) {}\r\n          if (i > stream.pos) { stream.pos = i; return null; }\r\n          stream.pos = l;\r\n          return \"trailingspace\";\r\n        },\r\n        name: \"trailingspace\"\r\n      });\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/search/searchcursor',[\"../../CodeMirror\"],function(CodeMirror) {\r\n  \"use strict\"\r\n  var Pos = CodeMirror.Pos\r\n\r\n  function regexpFlags(regexp) {\r\n    var flags = regexp.flags\r\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\r\n      + (regexp.global ? \"g\" : \"\")\r\n      + (regexp.multiline ? \"m\" : \"\")\r\n  }\r\n\r\n  function ensureFlags(regexp, flags) {\r\n    var current = regexpFlags(regexp), target = current\r\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\r\n      target += flags.charAt(i)\r\n    return current == target ? regexp : new RegExp(regexp.source, target)\r\n  }\r\n\r\n  function maybeMultiline(regexp) {\r\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\r\n  }\r\n\r\n  function searchRegexpForward(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"g\")\r\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\r\n      regexp.lastIndex = ch\r\n      var string = doc.getLine(line), match = regexp.exec(string)\r\n      if (match)\r\n        return {from: Pos(line, match.index),\r\n                to: Pos(line, match.index + match[0].length),\r\n                match: match}\r\n    }\r\n  }\r\n\r\n  function searchRegexpForwardMultiline(doc, regexp, start) {\r\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\r\n\r\n    regexp = ensureFlags(regexp, \"gm\")\r\n    var string, chunk = 1\r\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\r\n      // This grows the search buffer in exponentially-sized chunks\r\n      // between matches, so that nearby matches are fast and don't\r\n      // require concatenating the whole document (in case we're\r\n      // searching for something that has tons of matches), but at the\r\n      // same time, the amount of retries is limited.\r\n      for (var i = 0; i < chunk; i++) {\r\n        if (line > last) break\r\n        var curLine = doc.getLine(line++)\r\n        string = string == null ? curLine : string + \"\\n\" + curLine\r\n      }\r\n      chunk = chunk * 2\r\n      regexp.lastIndex = start.ch\r\n      var match = regexp.exec(string)\r\n      if (match) {\r\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\r\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\r\n        return {from: Pos(startLine, startCh),\r\n                to: Pos(startLine + inside.length - 1,\r\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\r\n                match: match}\r\n      }\r\n    }\r\n  }\r\n\r\n  function lastMatchIn(string, regexp) {\r\n    var cutOff = 0, match\r\n    for (;;) {\r\n      regexp.lastIndex = cutOff\r\n      var newMatch = regexp.exec(string)\r\n      if (!newMatch) return match\r\n      match = newMatch\r\n      cutOff = match.index + (match[0].length || 1)\r\n      if (cutOff == string.length) return match\r\n    }\r\n  }\r\n\r\n  function searchRegexpBackward(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"g\")\r\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\r\n      var string = doc.getLine(line)\r\n      if (ch > -1) string = string.slice(0, ch)\r\n      var match = lastMatchIn(string, regexp)\r\n      if (match)\r\n        return {from: Pos(line, match.index),\r\n                to: Pos(line, match.index + match[0].length),\r\n                match: match}\r\n    }\r\n  }\r\n\r\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"gm\")\r\n    var string, chunk = 1\r\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\r\n      for (var i = 0; i < chunk; i++) {\r\n        var curLine = doc.getLine(line--)\r\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\r\n      }\r\n      chunk *= 2\r\n\r\n      var match = lastMatchIn(string, regexp)\r\n      if (match) {\r\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\r\n        var startLine = line + before.length, startCh = before[before.length - 1].length\r\n        return {from: Pos(startLine, startCh),\r\n                to: Pos(startLine + inside.length - 1,\r\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\r\n                match: match}\r\n      }\r\n    }\r\n  }\r\n\r\n  var doFold, noFold\r\n  if (String.prototype.normalize) {\r\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\r\n    noFold = function(str) { return str.normalize(\"NFD\") }\r\n  } else {\r\n    doFold = function(str) { return str.toLowerCase() }\r\n    noFold = function(str) { return str }\r\n  }\r\n\r\n  // Maps a position in a case-folded line back to a position in the original line\r\n  // (compensating for codepoints increasing in number during folding)\r\n  function adjustPos(orig, folded, pos, foldFunc) {\r\n    if (orig.length == folded.length) return pos\r\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\r\n      if (min == max) return min\r\n      var mid = (min + max) >> 1\r\n      var len = foldFunc(orig.slice(0, mid)).length\r\n      if (len == pos) return mid\r\n      else if (len > pos) max = mid\r\n      else min = mid + 1\r\n    }\r\n  }\r\n\r\n  function searchStringForward(doc, query, start, caseFold) {\r\n    // Empty string would match anything and never progress, so we\r\n    // define it to match nothing instead.\r\n    if (!query.length) return null\r\n    var fold = caseFold ? doFold : noFold\r\n    var lines = fold(query).split(/\\r|\\n\\r?/)\r\n\r\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\r\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\r\n      if (lines.length == 1) {\r\n        var found = string.indexOf(lines[0])\r\n        if (found == -1) continue search\r\n        var start = adjustPos(orig, string, found, fold) + ch\r\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\r\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\r\n      } else {\r\n        var cutFrom = string.length - lines[0].length\r\n        if (string.slice(cutFrom) != lines[0]) continue search\r\n        for (var i = 1; i < lines.length - 1; i++)\r\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\r\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\r\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\r\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\r\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\r\n      }\r\n    }\r\n  }\r\n\r\n  function searchStringBackward(doc, query, start, caseFold) {\r\n    if (!query.length) return null\r\n    var fold = caseFold ? doFold : noFold\r\n    var lines = fold(query).split(/\\r|\\n\\r?/)\r\n\r\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\r\n      var orig = doc.getLine(line)\r\n      if (ch > -1) orig = orig.slice(0, ch)\r\n      var string = fold(orig)\r\n      if (lines.length == 1) {\r\n        var found = string.lastIndexOf(lines[0])\r\n        if (found == -1) continue search\r\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\r\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\r\n      } else {\r\n        var lastLine = lines[lines.length - 1]\r\n        if (string.slice(0, lastLine.length) != lastLine) continue search\r\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\r\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\r\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\r\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\r\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\r\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\r\n      }\r\n    }\r\n  }\r\n\r\n  function SearchCursor(doc, query, pos, options) {\r\n    this.atOccurrence = false\r\n    this.doc = doc\r\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\r\n    this.pos = {from: pos, to: pos}\r\n\r\n    var caseFold\r\n    if (typeof options == \"object\") {\r\n      caseFold = options.caseFold\r\n    } else { // Backwards compat for when caseFold was the 4th argument\r\n      caseFold = options\r\n      options = null\r\n    }\r\n\r\n    if (typeof query == \"string\") {\r\n      if (caseFold == null) caseFold = false\r\n      this.matches = function(reverse, pos) {\r\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\r\n      }\r\n    } else {\r\n      query = ensureFlags(query, \"gm\")\r\n      if (!options || options.multiline !== false)\r\n        this.matches = function(reverse, pos) {\r\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\r\n        }\r\n      else\r\n        this.matches = function(reverse, pos) {\r\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\r\n        }\r\n    }\r\n  }\r\n\r\n  SearchCursor.prototype = {\r\n    findNext: function() {return this.find(false)},\r\n    findPrevious: function() {return this.find(true)},\r\n\r\n    find: function(reverse) {\r\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\r\n\r\n      // Implements weird auto-growing behavior on null-matches for\r\n      // backwards-compatiblity with the vim code (unfortunately)\r\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\r\n        if (reverse) {\r\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\r\n          else if (result.from.line == this.doc.firstLine()) result = null\r\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\r\n        } else {\r\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\r\n          else if (result.to.line == this.doc.lastLine()) result = null\r\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\r\n        }\r\n      }\r\n\r\n      if (result) {\r\n        this.pos = result\r\n        this.atOccurrence = true\r\n        return this.pos.match || true\r\n      } else {\r\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\r\n        this.pos = {from: end, to: end}\r\n        return this.atOccurrence = false\r\n      }\r\n    },\r\n\r\n    from: function() {if (this.atOccurrence) return this.pos.from},\r\n    to: function() {if (this.atOccurrence) return this.pos.to},\r\n\r\n    replace: function(newText, origin) {\r\n      if (!this.atOccurrence) return\r\n      var lines = CodeMirror.splitLines(newText)\r\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\r\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\r\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\r\n    }\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\r\n    return new SearchCursor(this.doc, query, pos, caseFold)\r\n  })\r\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\r\n    return new SearchCursor(this, query, pos, caseFold)\r\n  })\r\n\r\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\r\n    var ranges = []\r\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\r\n    while (cur.findNext()) {\r\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\r\n      ranges.push({anchor: cur.from(), head: cur.to()})\r\n    }\r\n    if (ranges.length)\r\n      this.setSelections(ranges, 0)\r\n  })\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n// Open simple dialogs on top of an editor. Relies on dialog.css.\r\n\r\ndefine('skylark-codemirror/addon/dialog/dialog',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  function dialogDiv(cm, template, bottom) {\r\n    var wrap = cm.getWrapperElement();\r\n    var dialog;\r\n    dialog = wrap.appendChild(document.createElement(\"div\"));\r\n    if (bottom)\r\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\r\n    else\r\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\r\n\r\n    if (typeof template == \"string\") {\r\n      dialog.innerHTML = template;\r\n    } else { // Assuming it's a detached DOM element.\r\n      dialog.appendChild(template);\r\n    }\r\n    CodeMirror.addClass(wrap, 'dialog-opened');\r\n    return dialog;\r\n  }\r\n\r\n  function closeNotification(cm, newVal) {\r\n    if (cm.state.currentNotificationClose)\r\n      cm.state.currentNotificationClose();\r\n    cm.state.currentNotificationClose = newVal;\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\r\n    if (!options) options = {};\r\n\r\n    closeNotification(this, null);\r\n\r\n    var dialog = dialogDiv(this, template, options.bottom);\r\n    var closed = false, me = this;\r\n    function close(newVal) {\r\n      if (typeof newVal == 'string') {\r\n        inp.value = newVal;\r\n      } else {\r\n        if (closed) return;\r\n        closed = true;\r\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\r\n        dialog.parentNode.removeChild(dialog);\r\n        me.focus();\r\n\r\n        if (options.onClose) options.onClose(dialog);\r\n      }\r\n    }\r\n\r\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\r\n    if (inp) {\r\n      inp.focus();\r\n\r\n      if (options.value) {\r\n        inp.value = options.value;\r\n        if (options.selectValueOnOpen !== false) {\r\n          inp.select();\r\n        }\r\n      }\r\n\r\n      if (options.onInput)\r\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\r\n      if (options.onKeyUp)\r\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\r\n\r\n      CodeMirror.on(inp, \"keydown\", function(e) {\r\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\r\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\r\n          inp.blur();\r\n          CodeMirror.e_stop(e);\r\n          close();\r\n        }\r\n        if (e.keyCode == 13) callback(inp.value, e);\r\n      });\r\n\r\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\r\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\r\n      CodeMirror.on(button, \"click\", function() {\r\n        close();\r\n        me.focus();\r\n      });\r\n\r\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\r\n\r\n      button.focus();\r\n    }\r\n    return close;\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\r\n    closeNotification(this, null);\r\n    var dialog = dialogDiv(this, template, options && options.bottom);\r\n    var buttons = dialog.getElementsByTagName(\"button\");\r\n    var closed = false, me = this, blurring = 1;\r\n    function close() {\r\n      if (closed) return;\r\n      closed = true;\r\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\r\n      dialog.parentNode.removeChild(dialog);\r\n      me.focus();\r\n    }\r\n    buttons[0].focus();\r\n    for (var i = 0; i < buttons.length; ++i) {\r\n      var b = buttons[i];\r\n      (function(callback) {\r\n        CodeMirror.on(b, \"click\", function(e) {\r\n          CodeMirror.e_preventDefault(e);\r\n          close();\r\n          if (callback) callback(me);\r\n        });\r\n      })(callbacks[i]);\r\n      CodeMirror.on(b, \"blur\", function() {\r\n        --blurring;\r\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\r\n      });\r\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\r\n    }\r\n  });\r\n\r\n  /*\r\n   * openNotification\r\n   * Opens a notification, that can be closed with an optional timer\r\n   * (default 5000ms timer) and always closes on click.\r\n   *\r\n   * If a notification is opened while another is opened, it will close the\r\n   * currently opened one and open the new one immediately.\r\n   */\r\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\r\n    closeNotification(this, close);\r\n    var dialog = dialogDiv(this, template, options && options.bottom);\r\n    var closed = false, doneTimer;\r\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\r\n\r\n    function close() {\r\n      if (closed) return;\r\n      closed = true;\r\n      clearTimeout(doneTimer);\r\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\r\n      dialog.parentNode.removeChild(dialog);\r\n    }\r\n\r\n    CodeMirror.on(dialog, 'click', function(e) {\r\n      CodeMirror.e_preventDefault(e);\r\n      close();\r\n    });\r\n\r\n    if (duration)\r\n      doneTimer = setTimeout(close, duration);\r\n\r\n    return close;\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n// Define search commands. Depends on dialog.js or another\r\n// implementation of the openDialog method.\r\n\r\n// Replace works a little oddly -- it will do the replace on the next\r\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\r\n// replace by making sure the match is no longer selected when hitting\r\n// Ctrl-G.\r\n\r\ndefine('skylark-codemirror/addon/search/search',[\"../../CodeMirror\", \"./searchcursor\", \"../dialog/dialog\"],function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  function searchOverlay(query, caseInsensitive) {\r\n    if (typeof query == \"string\")\r\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\r\n    else if (!query.global)\r\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\r\n\r\n    return {token: function(stream) {\r\n      query.lastIndex = stream.pos;\r\n      var match = query.exec(stream.string);\r\n      if (match && match.index == stream.pos) {\r\n        stream.pos += match[0].length || 1;\r\n        return \"searching\";\r\n      } else if (match) {\r\n        stream.pos = match.index;\r\n      } else {\r\n        stream.skipToEnd();\r\n      }\r\n    }};\r\n  }\r\n\r\n  function SearchState() {\r\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\r\n    this.overlay = null;\r\n  }\r\n\r\n  function getSearchState(cm) {\r\n    return cm.state.search || (cm.state.search = new SearchState());\r\n  }\r\n\r\n  function queryCaseInsensitive(query) {\r\n    return typeof query == \"string\" && query == query.toLowerCase();\r\n  }\r\n\r\n  function getSearchCursor(cm, query, pos) {\r\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\r\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\r\n  }\r\n\r\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\r\n    cm.openDialog(text, onEnter, {\r\n      value: deflt,\r\n      selectValueOnOpen: true,\r\n      closeOnEnter: false,\r\n      onClose: function() { clearSearch(cm); },\r\n      onKeyDown: onKeyDown\r\n    });\r\n  }\r\n\r\n  function dialog(cm, text, shortText, deflt, f) {\r\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\r\n    else f(prompt(shortText, deflt));\r\n  }\r\n\r\n  function confirmDialog(cm, text, shortText, fs) {\r\n    if (cm.openConfirm) cm.openConfirm(text, fs);\r\n    else if (confirm(shortText)) fs[0]();\r\n  }\r\n\r\n  function parseString(string) {\r\n    return string.replace(/\\\\(.)/g, function(_, ch) {\r\n      if (ch == \"n\") return \"\\n\"\r\n      if (ch == \"r\") return \"\\r\"\r\n      return ch\r\n    })\r\n  }\r\n\r\n  function parseQuery(query) {\r\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\r\n    if (isRE) {\r\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\r\n      catch(e) {} // Not a regular expression after all, do a string search\r\n    } else {\r\n      query = parseString(query)\r\n    }\r\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\r\n      query = /x^/;\r\n    return query;\r\n  }\r\n\r\n  function startSearch(cm, state, query) {\r\n    state.queryText = query;\r\n    state.query = parseQuery(query);\r\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\r\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\r\n    cm.addOverlay(state.overlay);\r\n    if (cm.showMatchesOnScrollbar) {\r\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\r\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\r\n    }\r\n  }\r\n\r\n  function doSearch(cm, rev, persistent, immediate) {\r\n    var state = getSearchState(cm);\r\n    if (state.query) return findNext(cm, rev);\r\n    var q = cm.getSelection() || state.lastQuery;\r\n    if (q instanceof RegExp && q.source == \"x^\") q = null\r\n    if (persistent && cm.openDialog) {\r\n      var hiding = null\r\n      var searchNext = function(query, event) {\r\n        CodeMirror.e_stop(event);\r\n        if (!query) return;\r\n        if (query != state.queryText) {\r\n          startSearch(cm, state, query);\r\n          state.posFrom = state.posTo = cm.getCursor();\r\n        }\r\n        if (hiding) hiding.style.opacity = 1\r\n        findNext(cm, event.shiftKey, function(_, to) {\r\n          var dialog\r\n          if (to.line < 3 && document.querySelector &&\r\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\r\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\r\n            (hiding = dialog).style.opacity = .4\r\n        })\r\n      };\r\n      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {\r\n        var keyName = CodeMirror.keyName(event)\r\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\r\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\r\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\r\n          CodeMirror.e_stop(event);\r\n          startSearch(cm, getSearchState(cm), query);\r\n          cm.execCommand(cmd);\r\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\r\n          CodeMirror.e_stop(event);\r\n          searchNext(query, event);\r\n        }\r\n      });\r\n      if (immediate && q) {\r\n        startSearch(cm, state, q);\r\n        findNext(cm, rev);\r\n      }\r\n    } else {\r\n      dialog(cm, getQueryDialog(cm), \"Search for:\", q, function(query) {\r\n        if (query && !state.query) cm.operation(function() {\r\n          startSearch(cm, state, query);\r\n          state.posFrom = state.posTo = cm.getCursor();\r\n          findNext(cm, rev);\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  function findNext(cm, rev, callback) {cm.operation(function() {\r\n    var state = getSearchState(cm);\r\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\r\n    if (!cursor.find(rev)) {\r\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\r\n      if (!cursor.find(rev)) return;\r\n    }\r\n    cm.setSelection(cursor.from(), cursor.to());\r\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\r\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\r\n    if (callback) callback(cursor.from(), cursor.to())\r\n  });}\r\n\r\n  function clearSearch(cm) {cm.operation(function() {\r\n    var state = getSearchState(cm);\r\n    state.lastQuery = state.query;\r\n    if (!state.query) return;\r\n    state.query = state.queryText = null;\r\n    cm.removeOverlay(state.overlay);\r\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\r\n  });}\r\n\r\n\r\n  function getQueryDialog(cm)  {\r\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"Search:\") + '</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '</span>';\r\n  }\r\n  function getReplaceQueryDialog(cm) {\r\n    return ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '</span>';\r\n  }\r\n  function getReplacementQueryDialog(cm) {\r\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"With:\") + '</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\r\n  }\r\n  function getDoReplaceConfirm(cm) {\r\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"Replace?\") + '</span> <button>' + cm.phrase(\"Yes\") + '</button> <button>' + cm.phrase(\"No\") + '</button> <button>' + cm.phrase(\"All\") + '</button> <button>' + cm.phrase(\"Stop\") + '</button> ';\r\n  }\r\n\r\n  function replaceAll(cm, query, text) {\r\n    cm.operation(function() {\r\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\r\n        if (typeof query != \"string\") {\r\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\r\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\r\n        } else cursor.replace(text);\r\n      }\r\n    });\r\n  }\r\n\r\n  function replace(cm, all) {\r\n    if (cm.getOption(\"readOnly\")) return;\r\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\r\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? cm.phrase(\"Replace all:\") : cm.phrase(\"Replace:\")) + '</span>';\r\n    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {\r\n      if (!query) return;\r\n      query = parseQuery(query);\r\n      dialog(cm, getReplacementQueryDialog(cm), cm.phrase(\"Replace with:\"), \"\", function(text) {\r\n        text = parseString(text)\r\n        if (all) {\r\n          replaceAll(cm, query, text)\r\n        } else {\r\n          clearSearch(cm);\r\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\r\n          var advance = function() {\r\n            var start = cursor.from(), match;\r\n            if (!(match = cursor.findNext())) {\r\n              cursor = getSearchCursor(cm, query);\r\n              if (!(match = cursor.findNext()) ||\r\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\r\n            }\r\n            cm.setSelection(cursor.from(), cursor.to());\r\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\r\n            confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase(\"Replace?\"),\r\n                          [function() {doReplace(match);}, advance,\r\n                           function() {replaceAll(cm, query, text)}]);\r\n          };\r\n          var doReplace = function(match) {\r\n            cursor.replace(typeof query == \"string\" ? text :\r\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\r\n            advance();\r\n          };\r\n          advance();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\r\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\r\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\r\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\r\n  CodeMirror.commands.findNext = doSearch;\r\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\r\n  CodeMirror.commands.clearSearch = clearSearch;\r\n  CodeMirror.commands.replace = replace;\r\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/scroll/annotatescrollbar',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\r\n    if (typeof options == \"string\") options = {className: options};\r\n    return new Annotation(this, options);\r\n  });\r\n\r\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\r\n\r\n  function Annotation(cm, options) {\r\n    this.cm = cm;\r\n    this.options = options;\r\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\r\n    this.annotations = [];\r\n    this.doRedraw = this.doUpdate = null;\r\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\r\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\r\n    this.computeScale();\r\n\r\n    function scheduleRedraw(delay) {\r\n      clearTimeout(self.doRedraw);\r\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\r\n    }\r\n\r\n    var self = this;\r\n    cm.on(\"refresh\", this.resizeHandler = function() {\r\n      clearTimeout(self.doUpdate);\r\n      self.doUpdate = setTimeout(function() {\r\n        if (self.computeScale()) scheduleRedraw(20);\r\n      }, 100);\r\n    });\r\n    cm.on(\"markerAdded\", this.resizeHandler);\r\n    cm.on(\"markerCleared\", this.resizeHandler);\r\n    if (options.listenForChanges !== false)\r\n      cm.on(\"change\", this.changeHandler = function() {\r\n        scheduleRedraw(250);\r\n      });\r\n  }\r\n\r\n  Annotation.prototype.computeScale = function() {\r\n    var cm = this.cm;\r\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\r\n      cm.getScrollerElement().scrollHeight\r\n    if (hScale != this.hScale) {\r\n      this.hScale = hScale;\r\n      return true;\r\n    }\r\n  };\r\n\r\n  Annotation.prototype.update = function(annotations) {\r\n    this.annotations = annotations;\r\n    this.redraw();\r\n  };\r\n\r\n  Annotation.prototype.redraw = function(compute) {\r\n    if (compute !== false) this.computeScale();\r\n    var cm = this.cm, hScale = this.hScale;\r\n\r\n    var frag = document.createDocumentFragment(), anns = this.annotations;\r\n\r\n    var wrapping = cm.getOption(\"lineWrapping\");\r\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\r\n    var curLine = null, curLineObj = null;\r\n    function getY(pos, top) {\r\n      if (curLine != pos.line) {\r\n        curLine = pos.line;\r\n        curLineObj = cm.getLineHandle(curLine);\r\n      }\r\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\r\n          (wrapping && curLineObj.height > singleLineH))\r\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\r\n      var topY = cm.heightAtLine(curLineObj, \"local\");\r\n      return topY + (top ? 0 : curLineObj.height);\r\n    }\r\n\r\n    var lastLine = cm.lastLine()\r\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\r\n      var ann = anns[i];\r\n      if (ann.to.line > lastLine) continue;\r\n      var top = nextTop || getY(ann.from, true) * hScale;\r\n      var bottom = getY(ann.to, false) * hScale;\r\n      while (i < anns.length - 1) {\r\n        if (anns[i + 1].to.line > lastLine) break;\r\n        nextTop = getY(anns[i + 1].from, true) * hScale;\r\n        if (nextTop > bottom + .9) break;\r\n        ann = anns[++i];\r\n        bottom = getY(ann.to, false) * hScale;\r\n      }\r\n      if (bottom == top) continue;\r\n      var height = Math.max(bottom - top, 3);\r\n\r\n      var elt = frag.appendChild(document.createElement(\"div\"));\r\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\r\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\r\n      elt.className = this.options.className;\r\n      if (ann.id) {\r\n        elt.setAttribute(\"annotation-id\", ann.id);\r\n      }\r\n    }\r\n    this.div.textContent = \"\";\r\n    this.div.appendChild(frag);\r\n  };\r\n\r\n  Annotation.prototype.clear = function() {\r\n    this.cm.off(\"refresh\", this.resizeHandler);\r\n    this.cm.off(\"markerAdded\", this.resizeHandler);\r\n    this.cm.off(\"markerCleared\", this.resizeHandler);\r\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\r\n    this.div.parentNode.removeChild(this.div);\r\n  };\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/search/matchesonscrollbar',[\"../../CodeMirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\r\n    if (typeof options == \"string\") options = {className: options};\r\n    if (!options) options = {};\r\n    return new SearchAnnotation(this, query, caseFold, options);\r\n  });\r\n\r\n  function SearchAnnotation(cm, query, caseFold, options) {\r\n    this.cm = cm;\r\n    this.options = options;\r\n    var annotateOptions = {listenForChanges: false};\r\n    for (var prop in options) annotateOptions[prop] = options[prop];\r\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\r\n    this.annotation = cm.annotateScrollbar(annotateOptions);\r\n    this.query = query;\r\n    this.caseFold = caseFold;\r\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\r\n    this.matches = [];\r\n    this.update = null;\r\n\r\n    this.findMatches();\r\n    this.annotation.update(this.matches);\r\n\r\n    var self = this;\r\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\r\n  }\r\n\r\n  var MAX_MATCHES = 1000;\r\n\r\n  SearchAnnotation.prototype.findMatches = function() {\r\n    if (!this.gap) return;\r\n    for (var i = 0; i < this.matches.length; i++) {\r\n      var match = this.matches[i];\r\n      if (match.from.line >= this.gap.to) break;\r\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\r\n    }\r\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\r\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\r\n    while (cursor.findNext()) {\r\n      var match = {from: cursor.from(), to: cursor.to()};\r\n      if (match.from.line >= this.gap.to) break;\r\n      this.matches.splice(i++, 0, match);\r\n      if (this.matches.length > maxMatches) break;\r\n    }\r\n    this.gap = null;\r\n  };\r\n\r\n  function offsetLine(line, changeStart, sizeChange) {\r\n    if (line <= changeStart) return line;\r\n    return Math.max(changeStart, line + sizeChange);\r\n  }\r\n\r\n  SearchAnnotation.prototype.onChange = function(change) {\r\n    var startLine = change.from.line;\r\n    var endLine = CodeMirror.changeEnd(change).line;\r\n    var sizeChange = endLine - change.to.line;\r\n    if (this.gap) {\r\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\r\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\r\n    } else {\r\n      this.gap = {from: change.from.line, to: endLine + 1};\r\n    }\r\n\r\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\r\n      var match = this.matches[i];\r\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\r\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\r\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\r\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\r\n    }\r\n    clearTimeout(this.update);\r\n    var self = this;\r\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\r\n  };\r\n\r\n  SearchAnnotation.prototype.updateAfterChange = function() {\r\n    this.findMatches();\r\n    this.annotation.update(this.matches);\r\n  };\r\n\r\n  SearchAnnotation.prototype.clear = function() {\r\n    this.cm.off(\"change\", this.changeHandler);\r\n    this.annotation.clear();\r\n  };\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n// Highlighting text that matches the selection\r\n//\r\n// Defines an option highlightSelectionMatches, which, when enabled,\r\n// will style strings that match the selection throughout the\r\n// document.\r\n//\r\n// The option can be set to true to simply enable it, or to a\r\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\r\n// configure it. minChars is the minimum amount of characters that should be\r\n// selected for the behavior to occur, and style is the token style to\r\n// apply to the matches. This will be prefixed by \"cm-\" to create an\r\n// actual CSS class name. If wordsOnly is enabled, the matches will be\r\n// highlighted only if the selected text is a word. showToken, when enabled,\r\n// will cause the current token to be highlighted when nothing is selected.\r\n// delay is used to specify how much time to wait, in milliseconds, before\r\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\r\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\r\n\r\ndefine('skylark-codemirror/addon/search/match-highlighter',[\"../../CodeMirror\", \"./matchesonscrollbar\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var defaults = {\r\n    style: \"matchhighlight\",\r\n    minChars: 2,\r\n    delay: 100,\r\n    wordsOnly: false,\r\n    annotateScrollbar: false,\r\n    showToken: false,\r\n    trim: true\r\n  }\r\n\r\n  function State(options) {\r\n    this.options = {}\r\n    for (var name in defaults)\r\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\r\n    this.overlay = this.timeout = null;\r\n    this.matchesonscroll = null;\r\n    this.active = false;\r\n  }\r\n\r\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      removeOverlay(cm);\r\n      clearTimeout(cm.state.matchHighlighter.timeout);\r\n      cm.state.matchHighlighter = null;\r\n      cm.off(\"cursorActivity\", cursorActivity);\r\n      cm.off(\"focus\", onFocus)\r\n    }\r\n    if (val) {\r\n      var state = cm.state.matchHighlighter = new State(val);\r\n      if (cm.hasFocus()) {\r\n        state.active = true\r\n        highlightMatches(cm)\r\n      } else {\r\n        cm.on(\"focus\", onFocus)\r\n      }\r\n      cm.on(\"cursorActivity\", cursorActivity);\r\n    }\r\n  });\r\n\r\n  function cursorActivity(cm) {\r\n    var state = cm.state.matchHighlighter;\r\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\r\n  }\r\n\r\n  function onFocus(cm) {\r\n    var state = cm.state.matchHighlighter\r\n    if (!state.active) {\r\n      state.active = true\r\n      scheduleHighlight(cm, state)\r\n    }\r\n  }\r\n\r\n  function scheduleHighlight(cm, state) {\r\n    clearTimeout(state.timeout);\r\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\r\n  }\r\n\r\n  function addOverlay(cm, query, hasBoundary, style) {\r\n    var state = cm.state.matchHighlighter;\r\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\r\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\r\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") + \"\\\\b\") : query;\r\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\r\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\r\n    }\r\n  }\r\n\r\n  function removeOverlay(cm) {\r\n    var state = cm.state.matchHighlighter;\r\n    if (state.overlay) {\r\n      cm.removeOverlay(state.overlay);\r\n      state.overlay = null;\r\n      if (state.matchesonscroll) {\r\n        state.matchesonscroll.clear();\r\n        state.matchesonscroll = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  function highlightMatches(cm) {\r\n    cm.operation(function() {\r\n      var state = cm.state.matchHighlighter;\r\n      removeOverlay(cm);\r\n      if (!cm.somethingSelected() && state.options.showToken) {\r\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\r\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\r\n        while (start && re.test(line.charAt(start - 1))) --start;\r\n        while (end < line.length && re.test(line.charAt(end))) ++end;\r\n        if (start < end)\r\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\r\n        return;\r\n      }\r\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\r\n      if (from.line != to.line) return;\r\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\r\n      var selection = cm.getRange(from, to)\r\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\r\n      if (selection.length >= state.options.minChars)\r\n        addOverlay(cm, selection, false, state.options.style);\r\n    });\r\n  }\r\n\r\n  function isWord(cm, from, to) {\r\n    var str = cm.getRange(from, to);\r\n    if (str.match(/^\\w+$/) !== null) {\r\n        if (from.ch > 0) {\r\n            var pos = {line: from.line, ch: from.ch - 1};\r\n            var chr = cm.getRange(pos, from);\r\n            if (chr.match(/\\W/) === null) return false;\r\n        }\r\n        if (to.ch < cm.getLine(from.line).length) {\r\n            var pos = {line: to.line, ch: to.ch + 1};\r\n            var chr = cm.getRange(to, pos);\r\n            if (chr.match(/\\W/) === null) return false;\r\n        }\r\n        return true;\r\n    } else return false;\r\n  }\r\n\r\n  function boundariesAround(stream, re) {\r\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\r\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\r\n  }\r\n\r\n  function makeOverlay(query, hasBoundary, style) {\r\n    return {token: function(stream) {\r\n      if (stream.match(query) &&\r\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\r\n        return style;\r\n      stream.next();\r\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\r\n    }};\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/hint/anyword-hint',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n\r\n  var WORD = /[\\w$]+/, RANGE = 500;\r\n\r\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\r\n    var word = options && options.word || WORD;\r\n    var range = options && options.range || RANGE;\r\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\r\n    var end = cur.ch, start = end;\r\n    while (start && word.test(curLine.charAt(start - 1))) --start;\r\n    var curWord = start != end && curLine.slice(start, end);\r\n\r\n    var list = options && options.list || [], seen = {};\r\n    var re = new RegExp(word.source, \"g\");\r\n    for (var dir = -1; dir <= 1; dir += 2) {\r\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\r\n      for (; line != endLine; line += dir) {\r\n        var text = editor.getLine(line), m;\r\n        while (m = re.exec(text)) {\r\n          if (line == cur.line && m[0] === curWord) continue;\r\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\r\n            seen[m[0]] = true;\r\n            list.push(m[0]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/hint/javascript-hint',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  function forEach(arr, f) {\r\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\r\n  }\r\n\r\n  function arrayContains(arr, item) {\r\n    if (!Array.prototype.indexOf) {\r\n      var i = arr.length;\r\n      while (i--) {\r\n        if (arr[i] === item) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n    return arr.indexOf(item) != -1;\r\n  }\r\n\r\n  function scriptHint(editor, keywords, getToken, options) {\r\n    // Find the token at the cursor\r\n    var cur = editor.getCursor(), token = getToken(editor, cur);\r\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\r\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\r\n    if (innerMode.mode.helperType === \"json\") return;\r\n    token.state = innerMode.state;\r\n\r\n    // If it's not a 'word-style' token, ignore the token.\r\n    if (!/^[\\w$_]*$/.test(token.string)) {\r\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\r\n               type: token.string == \".\" ? \"property\" : null};\r\n    } else if (token.end > cur.ch) {\r\n      token.end = cur.ch;\r\n      token.string = token.string.slice(0, cur.ch - token.start);\r\n    }\r\n\r\n    var tprop = token;\r\n    // If it is a property, find out what it is a property of.\r\n    while (tprop.type == \"property\") {\r\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\r\n      if (tprop.string != \".\") return;\r\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\r\n      if (!context) var context = [];\r\n      context.push(tprop);\r\n    }\r\n    return {list: getCompletions(token, context, keywords, options),\r\n            from: Pos(cur.line, token.start),\r\n            to: Pos(cur.line, token.end)};\r\n  }\r\n\r\n  function javascriptHint(editor, options) {\r\n    return scriptHint(editor, javascriptKeywords,\r\n                      function (e, cur) {return e.getTokenAt(cur);},\r\n                      options);\r\n  };\r\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\r\n\r\n  function getCoffeeScriptToken(editor, cur) {\r\n  // This getToken, it is for coffeescript, imitates the behavior of\r\n  // getTokenAt method in javascript.js, that is, returning \"property\"\r\n  // type and treat \".\" as indepenent token.\r\n    var token = editor.getTokenAt(cur);\r\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\r\n      token.end = token.start;\r\n      token.string = '.';\r\n      token.type = \"property\";\r\n    }\r\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\r\n      token.type = \"property\";\r\n      token.start++;\r\n      token.string = token.string.replace(/\\./, '');\r\n    }\r\n    return token;\r\n  }\r\n\r\n  function coffeescriptHint(editor, options) {\r\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\r\n  }\r\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\r\n\r\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\r\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\r\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\r\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\r\n  var funcProps = \"prototype apply call bind\".split(\" \");\r\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" +\r\n                  \"if in import instanceof new null return super switch this throw true try typeof var void while with yield\").split(\" \");\r\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\r\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\r\n\r\n  function forAllProps(obj, callback) {\r\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\r\n      for (var name in obj) callback(name)\r\n    } else {\r\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\r\n        Object.getOwnPropertyNames(o).forEach(callback)\r\n    }\r\n  }\r\n\r\n  function getCompletions(token, context, keywords, options) {\r\n    var found = [], start = token.string, global = options && options.globalScope || window;\r\n    function maybeAdd(str) {\r\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\r\n    }\r\n    function gatherCompletions(obj) {\r\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\r\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\r\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\r\n      forAllProps(obj, maybeAdd)\r\n    }\r\n\r\n    if (context && context.length) {\r\n      // If this is a property, see if it belongs to some object we can\r\n      // find in the current environment.\r\n      var obj = context.pop(), base;\r\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\r\n        if (options && options.additionalContext)\r\n          base = options.additionalContext[obj.string];\r\n        if (!options || options.useGlobalScope !== false)\r\n          base = base || global[obj.string];\r\n      } else if (obj.type == \"string\") {\r\n        base = \"\";\r\n      } else if (obj.type == \"atom\") {\r\n        base = 1;\r\n      } else if (obj.type == \"function\") {\r\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\r\n            (typeof global.jQuery == 'function'))\r\n          base = global.jQuery();\r\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\r\n          base = global._();\r\n      }\r\n      while (base != null && context.length)\r\n        base = base[context.pop().string];\r\n      if (base != null) gatherCompletions(base);\r\n    } else {\r\n      // If not, just look in the global object and any local scope\r\n      // (reading into JS mode internals to get at the local and global variables)\r\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\r\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\r\n      if (!options || options.useGlobalScope !== false)\r\n        gatherCompletions(global);\r\n      forEach(keywords, maybeAdd);\r\n    }\r\n    return found;\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/lint/javascript-lint',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n  // declare global: JSHINT\r\n\r\n  function validator(text, options) {\r\n    if (!window.JSHINT) {\r\n      if (window.console) {\r\n        window.console.error(\"Error: window.JSHINT not defined, CodeMirror JavaScript linting cannot run.\");\r\n      }\r\n      return [];\r\n    }\r\n    if (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation\r\n      options.indent = 1; // JSHint default value is 4\r\n    JSHINT(text, options, options.globals);\r\n    var errors = JSHINT.data().errors, result = [];\r\n    if (errors) parseErrors(errors, result);\r\n    return result;\r\n  }\r\n\r\n  CodeMirror.registerHelper(\"lint\", \"javascript\", validator);\r\n\r\n  function parseErrors(errors, output) {\r\n    for ( var i = 0; i < errors.length; i++) {\r\n      var error = errors[i];\r\n      if (error) {\r\n        if (error.line <= 0) {\r\n          if (window.console) {\r\n            window.console.warn(\"Cannot display JSHint error (invalid line \" + error.line + \")\", error);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        var start = error.character - 1, end = start + 1;\r\n        if (error.evidence) {\r\n          var index = error.evidence.substring(start).search(/.\\b/);\r\n          if (index > -1) {\r\n            end += index;\r\n          }\r\n        }\r\n\r\n        // Convert to format expected by validation service\r\n        var hint = {\r\n          message: error.reason,\r\n          severity: error.code ? (error.code.startsWith('W') ? \"warning\" : \"error\") : \"error\",\r\n          from: CodeMirror.Pos(error.line - 1, start),\r\n          to: CodeMirror.Pos(error.line - 1, end)\r\n        };\r\n\r\n        output.push(hint);\r\n      }\r\n    }\r\n  }\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\ndefine('skylark-codemirror/addon/lint/lint',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\r\n\r\n  function showTooltip(e, content) {\r\n    var tt = document.createElement(\"div\");\r\n    tt.className = \"CodeMirror-lint-tooltip\";\r\n    tt.appendChild(content.cloneNode(true));\r\n    document.body.appendChild(tt);\r\n\r\n    function position(e) {\r\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\r\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\r\n      tt.style.left = (e.clientX + 5) + \"px\";\r\n    }\r\n    CodeMirror.on(document, \"mousemove\", position);\r\n    position(e);\r\n    if (tt.style.opacity != null) tt.style.opacity = 1;\r\n    return tt;\r\n  }\r\n  function rm(elt) {\r\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\r\n  }\r\n  function hideTooltip(tt) {\r\n    if (!tt.parentNode) return;\r\n    if (tt.style.opacity == null) rm(tt);\r\n    tt.style.opacity = 0;\r\n    setTimeout(function() { rm(tt); }, 600);\r\n  }\r\n\r\n  function showTooltipFor(e, content, node) {\r\n    var tooltip = showTooltip(e, content);\r\n    function hide() {\r\n      CodeMirror.off(node, \"mouseout\", hide);\r\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\r\n    }\r\n    var poll = setInterval(function() {\r\n      if (tooltip) for (var n = node;; n = n.parentNode) {\r\n        if (n && n.nodeType == 11) n = n.host;\r\n        if (n == document.body) return;\r\n        if (!n) { hide(); break; }\r\n      }\r\n      if (!tooltip) return clearInterval(poll);\r\n    }, 400);\r\n    CodeMirror.on(node, \"mouseout\", hide);\r\n  }\r\n\r\n  function LintState(cm, options, hasGutter) {\r\n    this.marked = [];\r\n    this.options = options;\r\n    this.timeout = null;\r\n    this.hasGutter = hasGutter;\r\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\r\n    this.waitingFor = 0\r\n  }\r\n\r\n  function parseOptions(_cm, options) {\r\n    if (options instanceof Function) return {getAnnotations: options};\r\n    if (!options || options === true) options = {};\r\n    return options;\r\n  }\r\n\r\n  function clearMarks(cm) {\r\n    var state = cm.state.lint;\r\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\r\n    for (var i = 0; i < state.marked.length; ++i)\r\n      state.marked[i].clear();\r\n    state.marked.length = 0;\r\n  }\r\n\r\n  function makeMarker(labels, severity, multiple, tooltips) {\r\n    var marker = document.createElement(\"div\"), inner = marker;\r\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\r\n    if (multiple) {\r\n      inner = marker.appendChild(document.createElement(\"div\"));\r\n      inner.className = \"CodeMirror-lint-marker-multiple\";\r\n    }\r\n\r\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\r\n      showTooltipFor(e, labels, inner);\r\n    });\r\n\r\n    return marker;\r\n  }\r\n\r\n  function getMaxSeverity(a, b) {\r\n    if (a == \"error\") return a;\r\n    else return b;\r\n  }\r\n\r\n  function groupByLine(annotations) {\r\n    var lines = [];\r\n    for (var i = 0; i < annotations.length; ++i) {\r\n      var ann = annotations[i], line = ann.from.line;\r\n      (lines[line] || (lines[line] = [])).push(ann);\r\n    }\r\n    return lines;\r\n  }\r\n\r\n  function annotationTooltip(ann) {\r\n    var severity = ann.severity;\r\n    if (!severity) severity = \"error\";\r\n    var tip = document.createElement(\"div\");\r\n    tip.className = \"CodeMirror-lint-message-\" + severity;\r\n    if (typeof ann.messageHTML != 'undefined') {\r\n        tip.innerHTML = ann.messageHTML;\r\n    } else {\r\n        tip.appendChild(document.createTextNode(ann.message));\r\n    }\r\n    return tip;\r\n  }\r\n\r\n  function lintAsync(cm, getAnnotations, passOptions) {\r\n    var state = cm.state.lint\r\n    var id = ++state.waitingFor\r\n    function abort() {\r\n      id = -1\r\n      cm.off(\"change\", abort)\r\n    }\r\n    cm.on(\"change\", abort)\r\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\r\n      cm.off(\"change\", abort)\r\n      if (state.waitingFor != id) return\r\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\r\n      cm.operation(function() {updateLinting(cm, annotations)})\r\n    }, passOptions, cm);\r\n  }\r\n\r\n  function startLinting(cm) {\r\n    var state = cm.state.lint, options = state.options;\r\n    /*\r\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\r\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\r\n     */\r\n    var passOptions = options.options || options;\r\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\r\n    if (!getAnnotations) return;\r\n    if (options.async || getAnnotations.async) {\r\n      lintAsync(cm, getAnnotations, passOptions)\r\n    } else {\r\n      var annotations = getAnnotations(cm.getValue(), passOptions, cm);\r\n      if (!annotations) return;\r\n      if (annotations.then) annotations.then(function(issues) {\r\n        cm.operation(function() {updateLinting(cm, issues)})\r\n      });\r\n      else cm.operation(function() {updateLinting(cm, annotations)})\r\n    }\r\n  }\r\n\r\n  function updateLinting(cm, annotationsNotSorted) {\r\n    clearMarks(cm);\r\n    var state = cm.state.lint, options = state.options;\r\n\r\n    var annotations = groupByLine(annotationsNotSorted);\r\n\r\n    for (var line = 0; line < annotations.length; ++line) {\r\n      var anns = annotations[line];\r\n      if (!anns) continue;\r\n\r\n      var maxSeverity = null;\r\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\r\n\r\n      for (var i = 0; i < anns.length; ++i) {\r\n        var ann = anns[i];\r\n        var severity = ann.severity;\r\n        if (!severity) severity = \"error\";\r\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\r\n\r\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\r\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\r\n\r\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\r\n          className: \"CodeMirror-lint-mark-\" + severity,\r\n          __annotation: ann\r\n        }));\r\n      }\r\n\r\n      if (state.hasGutter)\r\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\r\n                                                       state.options.tooltips));\r\n    }\r\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\r\n  }\r\n\r\n  function onChange(cm) {\r\n    var state = cm.state.lint;\r\n    if (!state) return;\r\n    clearTimeout(state.timeout);\r\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\r\n  }\r\n\r\n  function popupTooltips(annotations, e) {\r\n    var target = e.target || e.srcElement;\r\n    var tooltip = document.createDocumentFragment();\r\n    for (var i = 0; i < annotations.length; i++) {\r\n      var ann = annotations[i];\r\n      tooltip.appendChild(annotationTooltip(ann));\r\n    }\r\n    showTooltipFor(e, tooltip, target);\r\n  }\r\n\r\n  function onMouseOver(cm, e) {\r\n    var target = e.target || e.srcElement;\r\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\r\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\r\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\r\n\r\n    var annotations = [];\r\n    for (var i = 0; i < spans.length; ++i) {\r\n      var ann = spans[i].__annotation;\r\n      if (ann) annotations.push(ann);\r\n    }\r\n    if (annotations.length) popupTooltips(annotations, e);\r\n  }\r\n\r\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      clearMarks(cm);\r\n      if (cm.state.lint.options.lintOnChange !== false)\r\n        cm.off(\"change\", onChange);\r\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\r\n      clearTimeout(cm.state.lint.timeout);\r\n      delete cm.state.lint;\r\n    }\r\n\r\n    if (val) {\r\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\r\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\r\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\r\n      if (state.options.lintOnChange !== false)\r\n        cm.on(\"change\", onChange);\r\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\r\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\r\n\r\n      startLinting(cm);\r\n    }\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"performLint\", function() {\r\n    if (this.state.lint) startLinting(this);\r\n  });\r\n});\r\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n// Glue code between CodeMirror and Tern.\r\n//\r\n// Create a CodeMirror.TernServer to wrap an actual Tern server,\r\n// register open documents (CodeMirror.Doc instances) with it, and\r\n// call its methods to activate the assisting functions that Tern\r\n// provides.\r\n//\r\n// Options supported (all optional):\r\n// * defs: An array of JSON definition data structures.\r\n// * plugins: An object mapping plugin names to configuration\r\n//   options.\r\n// * getFile: A function(name, c) that can be used to access files in\r\n//   the project that haven't been loaded yet. Simply do c(null) to\r\n//   indicate that a file is not available.\r\n// * fileFilter: A function(value, docName, doc) that will be applied\r\n//   to documents before passing them on to Tern.\r\n// * switchToDoc: A function(name, doc) that should, when providing a\r\n//   multi-file view, switch the view or focus to the named file.\r\n// * showError: A function(editor, message) that can be used to\r\n//   override the way errors are displayed.\r\n// * completionTip: Customize the content in tooltips for completions.\r\n//   Is passed a single argument—the completion's data as returned by\r\n//   Tern—and may return a string, DOM node, or null to indicate that\r\n//   no tip should be shown. By default the docstring is shown.\r\n// * typeTip: Like completionTip, but for the tooltips shown for type\r\n//   queries.\r\n// * responseFilter: A function(doc, query, request, error, data) that\r\n//   will be applied to the Tern responses before treating them\r\n//\r\n//\r\n// It is possible to run the Tern server in a web worker by specifying\r\n// these additional options:\r\n// * useWorker: Set to true to enable web worker mode. You'll probably\r\n//   want to feature detect the actual value you use here, for example\r\n//   !!window.Worker.\r\n// * workerScript: The main script of the worker. Point this to\r\n//   wherever you are hosting worker.js from this directory.\r\n// * workerDeps: An array of paths pointing (relative to workerScript)\r\n//   to the Acorn and Tern libraries and any Tern plugins you want to\r\n//   load. Or, if you minified those into a single script and included\r\n//   them in the workerScript, simply leave this undefined.\r\n\r\ndefine('skylark-codemirror/addon/tern/tern',[\"../../CodeMirror\"], function(CodeMirror) {\r\n  \"use strict\";\r\n  // declare global: tern\r\n\r\n  CodeMirror.TernServer = function(options) {\r\n    var self = this;\r\n    this.options = options || {};\r\n    var plugins = this.options.plugins || (this.options.plugins = {});\r\n    if (!plugins.doc_comment) plugins.doc_comment = true;\r\n    this.docs = Object.create(null);\r\n    if (this.options.useWorker) {\r\n      this.server = new WorkerServer(this);\r\n    } else {\r\n      this.server = new tern.Server({\r\n        getFile: function(name, c) { return getFile(self, name, c); },\r\n        async: true,\r\n        defs: this.options.defs || [],\r\n        plugins: plugins\r\n      });\r\n    }\r\n    this.trackChange = function(doc, change) { trackChange(self, doc, change); };\r\n\r\n    this.cachedArgHints = null;\r\n    this.activeArgHints = null;\r\n    this.jumpStack = [];\r\n\r\n    this.getHint = function(cm, c) { return hint(self, cm, c); };\r\n    this.getHint.async = true;\r\n  };\r\n\r\n  CodeMirror.TernServer.prototype = {\r\n    addDoc: function(name, doc) {\r\n      var data = {doc: doc, name: name, changed: null};\r\n      this.server.addFile(name, docValue(this, data));\r\n      CodeMirror.on(doc, \"change\", this.trackChange);\r\n      return this.docs[name] = data;\r\n    },\r\n\r\n    delDoc: function(id) {\r\n      var found = resolveDoc(this, id);\r\n      if (!found) return;\r\n      CodeMirror.off(found.doc, \"change\", this.trackChange);\r\n      delete this.docs[found.name];\r\n      this.server.delFile(found.name);\r\n    },\r\n\r\n    hideDoc: function(id) {\r\n      closeArgHints(this);\r\n      var found = resolveDoc(this, id);\r\n      if (found && found.changed) sendDoc(this, found);\r\n    },\r\n\r\n    complete: function(cm) {\r\n      cm.showHint({hint: this.getHint});\r\n    },\r\n\r\n    showType: function(cm, pos, c) { showContextInfo(this, cm, pos, \"type\", c); },\r\n\r\n    showDocs: function(cm, pos, c) { showContextInfo(this, cm, pos, \"documentation\", c); },\r\n\r\n    updateArgHints: function(cm) { updateArgHints(this, cm); },\r\n\r\n    jumpToDef: function(cm) { jumpToDef(this, cm); },\r\n\r\n    jumpBack: function(cm) { jumpBack(this, cm); },\r\n\r\n    rename: function(cm) { rename(this, cm); },\r\n\r\n    selectName: function(cm) { selectName(this, cm); },\r\n\r\n    request: function (cm, query, c, pos) {\r\n      var self = this;\r\n      var doc = findDoc(this, cm.getDoc());\r\n      var request = buildRequest(this, doc, query, pos);\r\n      var extraOptions = request.query && this.options.queryOptions && this.options.queryOptions[request.query.type]\r\n      if (extraOptions) for (var prop in extraOptions) request.query[prop] = extraOptions[prop];\r\n\r\n      this.server.request(request, function (error, data) {\r\n        if (!error && self.options.responseFilter)\r\n          data = self.options.responseFilter(doc, query, request, error, data);\r\n        c(error, data);\r\n      });\r\n    },\r\n\r\n    destroy: function () {\r\n      closeArgHints(this)\r\n      if (this.worker) {\r\n        this.worker.terminate();\r\n        this.worker = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  var Pos = CodeMirror.Pos;\r\n  var cls = \"CodeMirror-Tern-\";\r\n  var bigDoc = 250;\r\n\r\n  function getFile(ts, name, c) {\r\n    var buf = ts.docs[name];\r\n    if (buf)\r\n      c(docValue(ts, buf));\r\n    else if (ts.options.getFile)\r\n      ts.options.getFile(name, c);\r\n    else\r\n      c(null);\r\n  }\r\n\r\n  function findDoc(ts, doc, name) {\r\n    for (var n in ts.docs) {\r\n      var cur = ts.docs[n];\r\n      if (cur.doc == doc) return cur;\r\n    }\r\n    if (!name) for (var i = 0;; ++i) {\r\n      n = \"[doc\" + (i || \"\") + \"]\";\r\n      if (!ts.docs[n]) { name = n; break; }\r\n    }\r\n    return ts.addDoc(name, doc);\r\n  }\r\n\r\n  function resolveDoc(ts, id) {\r\n    if (typeof id == \"string\") return ts.docs[id];\r\n    if (id instanceof CodeMirror) id = id.getDoc();\r\n    if (id instanceof CodeMirror.Doc) return findDoc(ts, id);\r\n  }\r\n\r\n  function trackChange(ts, doc, change) {\r\n    var data = findDoc(ts, doc);\r\n\r\n    var argHints = ts.cachedArgHints;\r\n    if (argHints && argHints.doc == doc && cmpPos(argHints.start, change.to) >= 0)\r\n      ts.cachedArgHints = null;\r\n\r\n    var changed = data.changed;\r\n    if (changed == null)\r\n      data.changed = changed = {from: change.from.line, to: change.from.line};\r\n    var end = change.from.line + (change.text.length - 1);\r\n    if (change.from.line < changed.to) changed.to = changed.to - (change.to.line - end);\r\n    if (end >= changed.to) changed.to = end + 1;\r\n    if (changed.from > change.from.line) changed.from = change.from.line;\r\n\r\n    if (doc.lineCount() > bigDoc && change.to - changed.from > 100) setTimeout(function() {\r\n      if (data.changed && data.changed.to - data.changed.from > 100) sendDoc(ts, data);\r\n    }, 200);\r\n  }\r\n\r\n  function sendDoc(ts, doc) {\r\n    ts.server.request({files: [{type: \"full\", name: doc.name, text: docValue(ts, doc)}]}, function(error) {\r\n      if (error) window.console.error(error);\r\n      else doc.changed = null;\r\n    });\r\n  }\r\n\r\n  // Completion\r\n\r\n  function hint(ts, cm, c) {\r\n    ts.request(cm, {type: \"completions\", types: true, docs: true, urls: true}, function(error, data) {\r\n      if (error) return showError(ts, cm, error);\r\n      var completions = [], after = \"\";\r\n      var from = data.start, to = data.end;\r\n      if (cm.getRange(Pos(from.line, from.ch - 2), from) == \"[\\\"\" &&\r\n          cm.getRange(to, Pos(to.line, to.ch + 2)) != \"\\\"]\")\r\n        after = \"\\\"]\";\r\n\r\n      for (var i = 0; i < data.completions.length; ++i) {\r\n        var completion = data.completions[i], className = typeToIcon(completion.type);\r\n        if (data.guess) className += \" \" + cls + \"guess\";\r\n        completions.push({text: completion.name + after,\r\n                          displayText: completion.displayName || completion.name,\r\n                          className: className,\r\n                          data: completion});\r\n      }\r\n\r\n      var obj = {from: from, to: to, list: completions};\r\n      var tooltip = null;\r\n      CodeMirror.on(obj, \"close\", function() { remove(tooltip); });\r\n      CodeMirror.on(obj, \"update\", function() { remove(tooltip); });\r\n      CodeMirror.on(obj, \"select\", function(cur, node) {\r\n        remove(tooltip);\r\n        var content = ts.options.completionTip ? ts.options.completionTip(cur.data) : cur.data.doc;\r\n        if (content) {\r\n          tooltip = makeTooltip(node.parentNode.getBoundingClientRect().right + window.pageXOffset,\r\n                                node.getBoundingClientRect().top + window.pageYOffset, content);\r\n          tooltip.className += \" \" + cls + \"hint-doc\";\r\n        }\r\n      });\r\n      c(obj);\r\n    });\r\n  }\r\n\r\n  function typeToIcon(type) {\r\n    var suffix;\r\n    if (type == \"?\") suffix = \"unknown\";\r\n    else if (type == \"number\" || type == \"string\" || type == \"bool\") suffix = type;\r\n    else if (/^fn\\(/.test(type)) suffix = \"fn\";\r\n    else if (/^\\[/.test(type)) suffix = \"array\";\r\n    else suffix = \"object\";\r\n    return cls + \"completion \" + cls + \"completion-\" + suffix;\r\n  }\r\n\r\n  // Type queries\r\n\r\n  function showContextInfo(ts, cm, pos, queryName, c) {\r\n    ts.request(cm, queryName, function(error, data) {\r\n      if (error) return showError(ts, cm, error);\r\n      if (ts.options.typeTip) {\r\n        var tip = ts.options.typeTip(data);\r\n      } else {\r\n        var tip = elt(\"span\", null, elt(\"strong\", null, data.type || \"not found\"));\r\n        if (data.doc)\r\n          tip.appendChild(document.createTextNode(\" — \" + data.doc));\r\n        if (data.url) {\r\n          tip.appendChild(document.createTextNode(\" \"));\r\n          var child = tip.appendChild(elt(\"a\", null, \"[docs]\"));\r\n          child.href = data.url;\r\n          child.target = \"_blank\";\r\n        }\r\n      }\r\n      tempTooltip(cm, tip, ts);\r\n      if (c) c();\r\n    }, pos);\r\n  }\r\n\r\n  // Maintaining argument hints\r\n\r\n  function updateArgHints(ts, cm) {\r\n    closeArgHints(ts);\r\n\r\n    if (cm.somethingSelected()) return;\r\n    var state = cm.getTokenAt(cm.getCursor()).state;\r\n    var inner = CodeMirror.innerMode(cm.getMode(), state);\r\n    if (inner.mode.name != \"javascript\") return;\r\n    var lex = inner.state.lexical;\r\n    if (lex.info != \"call\") return;\r\n\r\n    var ch, argPos = lex.pos || 0, tabSize = cm.getOption(\"tabSize\");\r\n    for (var line = cm.getCursor().line, e = Math.max(0, line - 9), found = false; line >= e; --line) {\r\n      var str = cm.getLine(line), extra = 0;\r\n      for (var pos = 0;;) {\r\n        var tab = str.indexOf(\"\\t\", pos);\r\n        if (tab == -1) break;\r\n        extra += tabSize - (tab + extra) % tabSize - 1;\r\n        pos = tab + 1;\r\n      }\r\n      ch = lex.column - extra;\r\n      if (str.charAt(ch) == \"(\") {found = true; break;}\r\n    }\r\n    if (!found) return;\r\n\r\n    var start = Pos(line, ch);\r\n    var cache = ts.cachedArgHints;\r\n    if (cache && cache.doc == cm.getDoc() && cmpPos(start, cache.start) == 0)\r\n      return showArgHints(ts, cm, argPos);\r\n\r\n    ts.request(cm, {type: \"type\", preferFunction: true, end: start}, function(error, data) {\r\n      if (error || !data.type || !(/^fn\\(/).test(data.type)) return;\r\n      ts.cachedArgHints = {\r\n        start: start,\r\n        type: parseFnType(data.type),\r\n        name: data.exprName || data.name || \"fn\",\r\n        guess: data.guess,\r\n        doc: cm.getDoc()\r\n      };\r\n      showArgHints(ts, cm, argPos);\r\n    });\r\n  }\r\n\r\n  function showArgHints(ts, cm, pos) {\r\n    closeArgHints(ts);\r\n\r\n    var cache = ts.cachedArgHints, tp = cache.type;\r\n    var tip = elt(\"span\", cache.guess ? cls + \"fhint-guess\" : null,\r\n                  elt(\"span\", cls + \"fname\", cache.name), \"(\");\r\n    for (var i = 0; i < tp.args.length; ++i) {\r\n      if (i) tip.appendChild(document.createTextNode(\", \"));\r\n      var arg = tp.args[i];\r\n      tip.appendChild(elt(\"span\", cls + \"farg\" + (i == pos ? \" \" + cls + \"farg-current\" : \"\"), arg.name || \"?\"));\r\n      if (arg.type != \"?\") {\r\n        tip.appendChild(document.createTextNode(\":\\u00a0\"));\r\n        tip.appendChild(elt(\"span\", cls + \"type\", arg.type));\r\n      }\r\n    }\r\n    tip.appendChild(document.createTextNode(tp.rettype ? \") ->\\u00a0\" : \")\"));\r\n    if (tp.rettype) tip.appendChild(elt(\"span\", cls + \"type\", tp.rettype));\r\n    var place = cm.cursorCoords(null, \"page\");\r\n    var tooltip = ts.activeArgHints = makeTooltip(place.right + 1, place.bottom, tip)\r\n    setTimeout(function() {\r\n      tooltip.clear = onEditorActivity(cm, function() {\r\n        if (ts.activeArgHints == tooltip) closeArgHints(ts) })\r\n    }, 20)\r\n  }\r\n\r\n  function parseFnType(text) {\r\n    var args = [], pos = 3;\r\n\r\n    function skipMatching(upto) {\r\n      var depth = 0, start = pos;\r\n      for (;;) {\r\n        var next = text.charAt(pos);\r\n        if (upto.test(next) && !depth) return text.slice(start, pos);\r\n        if (/[{\\[\\(]/.test(next)) ++depth;\r\n        else if (/[}\\]\\)]/.test(next)) --depth;\r\n        ++pos;\r\n      }\r\n    }\r\n\r\n    // Parse arguments\r\n    if (text.charAt(pos) != \")\") for (;;) {\r\n      var name = text.slice(pos).match(/^([^, \\(\\[\\{]+): /);\r\n      if (name) {\r\n        pos += name[0].length;\r\n        name = name[1];\r\n      }\r\n      args.push({name: name, type: skipMatching(/[\\),]/)});\r\n      if (text.charAt(pos) == \")\") break;\r\n      pos += 2;\r\n    }\r\n\r\n    var rettype = text.slice(pos).match(/^\\) -> (.*)$/);\r\n\r\n    return {args: args, rettype: rettype && rettype[1]};\r\n  }\r\n\r\n  // Moving to the definition of something\r\n\r\n  function jumpToDef(ts, cm) {\r\n    function inner(varName) {\r\n      var req = {type: \"definition\", variable: varName || null};\r\n      var doc = findDoc(ts, cm.getDoc());\r\n      ts.server.request(buildRequest(ts, doc, req), function(error, data) {\r\n        if (error) return showError(ts, cm, error);\r\n        if (!data.file && data.url) { window.open(data.url); return; }\r\n\r\n        if (data.file) {\r\n          var localDoc = ts.docs[data.file], found;\r\n          if (localDoc && (found = findContext(localDoc.doc, data))) {\r\n            ts.jumpStack.push({file: doc.name,\r\n                               start: cm.getCursor(\"from\"),\r\n                               end: cm.getCursor(\"to\")});\r\n            moveTo(ts, doc, localDoc, found.start, found.end);\r\n            return;\r\n          }\r\n        }\r\n        showError(ts, cm, \"Could not find a definition.\");\r\n      });\r\n    }\r\n\r\n    if (!atInterestingExpression(cm))\r\n      dialog(cm, \"Jump to variable\", function(name) { if (name) inner(name); });\r\n    else\r\n      inner();\r\n  }\r\n\r\n  function jumpBack(ts, cm) {\r\n    var pos = ts.jumpStack.pop(), doc = pos && ts.docs[pos.file];\r\n    if (!doc) return;\r\n    moveTo(ts, findDoc(ts, cm.getDoc()), doc, pos.start, pos.end);\r\n  }\r\n\r\n  function moveTo(ts, curDoc, doc, start, end) {\r\n    doc.doc.setSelection(start, end);\r\n    if (curDoc != doc && ts.options.switchToDoc) {\r\n      closeArgHints(ts);\r\n      ts.options.switchToDoc(doc.name, doc.doc);\r\n    }\r\n  }\r\n\r\n  // The {line,ch} representation of positions makes this rather awkward.\r\n  function findContext(doc, data) {\r\n    var before = data.context.slice(0, data.contextOffset).split(\"\\n\");\r\n    var startLine = data.start.line - (before.length - 1);\r\n    var start = Pos(startLine, (before.length == 1 ? data.start.ch : doc.getLine(startLine).length) - before[0].length);\r\n\r\n    var text = doc.getLine(startLine).slice(start.ch);\r\n    for (var cur = startLine + 1; cur < doc.lineCount() && text.length < data.context.length; ++cur)\r\n      text += \"\\n\" + doc.getLine(cur);\r\n    if (text.slice(0, data.context.length) == data.context) return data;\r\n\r\n    var cursor = doc.getSearchCursor(data.context, 0, false);\r\n    var nearest, nearestDist = Infinity;\r\n    while (cursor.findNext()) {\r\n      var from = cursor.from(), dist = Math.abs(from.line - start.line) * 10000;\r\n      if (!dist) dist = Math.abs(from.ch - start.ch);\r\n      if (dist < nearestDist) { nearest = from; nearestDist = dist; }\r\n    }\r\n    if (!nearest) return null;\r\n\r\n    if (before.length == 1)\r\n      nearest.ch += before[0].length;\r\n    else\r\n      nearest = Pos(nearest.line + (before.length - 1), before[before.length - 1].length);\r\n    if (data.start.line == data.end.line)\r\n      var end = Pos(nearest.line, nearest.ch + (data.end.ch - data.start.ch));\r\n    else\r\n      var end = Pos(nearest.line + (data.end.line - data.start.line), data.end.ch);\r\n    return {start: nearest, end: end};\r\n  }\r\n\r\n  function atInterestingExpression(cm) {\r\n    var pos = cm.getCursor(\"end\"), tok = cm.getTokenAt(pos);\r\n    if (tok.start < pos.ch && tok.type == \"comment\") return false;\r\n    return /[\\w)\\]]/.test(cm.getLine(pos.line).slice(Math.max(pos.ch - 1, 0), pos.ch + 1));\r\n  }\r\n\r\n  // Variable renaming\r\n\r\n  function rename(ts, cm) {\r\n    var token = cm.getTokenAt(cm.getCursor());\r\n    if (!/\\w/.test(token.string)) return showError(ts, cm, \"Not at a variable\");\r\n    dialog(cm, \"New name for \" + token.string, function(newName) {\r\n      ts.request(cm, {type: \"rename\", newName: newName, fullDocs: true}, function(error, data) {\r\n        if (error) return showError(ts, cm, error);\r\n        applyChanges(ts, data.changes);\r\n      });\r\n    });\r\n  }\r\n\r\n  function selectName(ts, cm) {\r\n    var name = findDoc(ts, cm.doc).name;\r\n    ts.request(cm, {type: \"refs\"}, function(error, data) {\r\n      if (error) return showError(ts, cm, error);\r\n      var ranges = [], cur = 0;\r\n      var curPos = cm.getCursor();\r\n      for (var i = 0; i < data.refs.length; i++) {\r\n        var ref = data.refs[i];\r\n        if (ref.file == name) {\r\n          ranges.push({anchor: ref.start, head: ref.end});\r\n          if (cmpPos(curPos, ref.start) >= 0 && cmpPos(curPos, ref.end) <= 0)\r\n            cur = ranges.length - 1;\r\n        }\r\n      }\r\n      cm.setSelections(ranges, cur);\r\n    });\r\n  }\r\n\r\n  var nextChangeOrig = 0;\r\n  function applyChanges(ts, changes) {\r\n    var perFile = Object.create(null);\r\n    for (var i = 0; i < changes.length; ++i) {\r\n      var ch = changes[i];\r\n      (perFile[ch.file] || (perFile[ch.file] = [])).push(ch);\r\n    }\r\n    for (var file in perFile) {\r\n      var known = ts.docs[file], chs = perFile[file];;\r\n      if (!known) continue;\r\n      chs.sort(function(a, b) { return cmpPos(b.start, a.start); });\r\n      var origin = \"*rename\" + (++nextChangeOrig);\r\n      for (var i = 0; i < chs.length; ++i) {\r\n        var ch = chs[i];\r\n        known.doc.replaceRange(ch.text, ch.start, ch.end, origin);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Generic request-building helper\r\n\r\n  function buildRequest(ts, doc, query, pos) {\r\n    var files = [], offsetLines = 0, allowFragments = !query.fullDocs;\r\n    if (!allowFragments) delete query.fullDocs;\r\n    if (typeof query == \"string\") query = {type: query};\r\n    query.lineCharPositions = true;\r\n    if (query.end == null) {\r\n      query.end = pos || doc.doc.getCursor(\"end\");\r\n      if (doc.doc.somethingSelected())\r\n        query.start = doc.doc.getCursor(\"start\");\r\n    }\r\n    var startPos = query.start || query.end;\r\n\r\n    if (doc.changed) {\r\n      if (doc.doc.lineCount() > bigDoc && allowFragments !== false &&\r\n          doc.changed.to - doc.changed.from < 100 &&\r\n          doc.changed.from <= startPos.line && doc.changed.to > query.end.line) {\r\n        files.push(getFragmentAround(doc, startPos, query.end));\r\n        query.file = \"#0\";\r\n        var offsetLines = files[0].offsetLines;\r\n        if (query.start != null) query.start = Pos(query.start.line - -offsetLines, query.start.ch);\r\n        query.end = Pos(query.end.line - offsetLines, query.end.ch);\r\n      } else {\r\n        files.push({type: \"full\",\r\n                    name: doc.name,\r\n                    text: docValue(ts, doc)});\r\n        query.file = doc.name;\r\n        doc.changed = null;\r\n      }\r\n    } else {\r\n      query.file = doc.name;\r\n    }\r\n    for (var name in ts.docs) {\r\n      var cur = ts.docs[name];\r\n      if (cur.changed && cur != doc) {\r\n        files.push({type: \"full\", name: cur.name, text: docValue(ts, cur)});\r\n        cur.changed = null;\r\n      }\r\n    }\r\n\r\n    return {query: query, files: files};\r\n  }\r\n\r\n  function getFragmentAround(data, start, end) {\r\n    var doc = data.doc;\r\n    var minIndent = null, minLine = null, endLine, tabSize = 4;\r\n    for (var p = start.line - 1, min = Math.max(0, p - 50); p >= min; --p) {\r\n      var line = doc.getLine(p), fn = line.search(/\\bfunction\\b/);\r\n      if (fn < 0) continue;\r\n      var indent = CodeMirror.countColumn(line, null, tabSize);\r\n      if (minIndent != null && minIndent <= indent) continue;\r\n      minIndent = indent;\r\n      minLine = p;\r\n    }\r\n    if (minLine == null) minLine = min;\r\n    var max = Math.min(doc.lastLine(), end.line + 20);\r\n    if (minIndent == null || minIndent == CodeMirror.countColumn(doc.getLine(start.line), null, tabSize))\r\n      endLine = max;\r\n    else for (endLine = end.line + 1; endLine < max; ++endLine) {\r\n      var indent = CodeMirror.countColumn(doc.getLine(endLine), null, tabSize);\r\n      if (indent <= minIndent) break;\r\n    }\r\n    var from = Pos(minLine, 0);\r\n\r\n    return {type: \"part\",\r\n            name: data.name,\r\n            offsetLines: from.line,\r\n            text: doc.getRange(from, Pos(endLine, end.line == endLine ? null : 0))};\r\n  }\r\n\r\n  // Generic utilities\r\n\r\n  var cmpPos = CodeMirror.cmpPos;\r\n\r\n  function elt(tagname, cls /*, ... elts*/) {\r\n    var e = document.createElement(tagname);\r\n    if (cls) e.className = cls;\r\n    for (var i = 2; i < arguments.length; ++i) {\r\n      var elt = arguments[i];\r\n      if (typeof elt == \"string\") elt = document.createTextNode(elt);\r\n      e.appendChild(elt);\r\n    }\r\n    return e;\r\n  }\r\n\r\n  function dialog(cm, text, f) {\r\n    if (cm.openDialog)\r\n      cm.openDialog(text + \": <input type=text>\", f);\r\n    else\r\n      f(prompt(text, \"\"));\r\n  }\r\n\r\n  // Tooltips\r\n\r\n  function tempTooltip(cm, content, ts) {\r\n    if (cm.state.ternTooltip) remove(cm.state.ternTooltip);\r\n    var where = cm.cursorCoords();\r\n    var tip = cm.state.ternTooltip = makeTooltip(where.right + 1, where.bottom, content);\r\n    function maybeClear() {\r\n      old = true;\r\n      if (!mouseOnTip) clear();\r\n    }\r\n    function clear() {\r\n      cm.state.ternTooltip = null;\r\n      if (tip.parentNode) fadeOut(tip)\r\n      clearActivity()\r\n    }\r\n    var mouseOnTip = false, old = false;\r\n    CodeMirror.on(tip, \"mousemove\", function() { mouseOnTip = true; });\r\n    CodeMirror.on(tip, \"mouseout\", function(e) {\r\n      var related = e.relatedTarget || e.toElement\r\n      if (!related || !CodeMirror.contains(tip, related)) {\r\n        if (old) clear();\r\n        else mouseOnTip = false;\r\n      }\r\n    });\r\n    setTimeout(maybeClear, ts.options.hintDelay ? ts.options.hintDelay : 1700);\r\n    var clearActivity = onEditorActivity(cm, clear)\r\n  }\r\n\r\n  function onEditorActivity(cm, f) {\r\n    cm.on(\"cursorActivity\", f)\r\n    cm.on(\"blur\", f)\r\n    cm.on(\"scroll\", f)\r\n    cm.on(\"setDoc\", f)\r\n    return function() {\r\n      cm.off(\"cursorActivity\", f)\r\n      cm.off(\"blur\", f)\r\n      cm.off(\"scroll\", f)\r\n      cm.off(\"setDoc\", f)\r\n    }\r\n  }\r\n\r\n  function makeTooltip(x, y, content) {\r\n    var node = elt(\"div\", cls + \"tooltip\", content);\r\n    node.style.left = x + \"px\";\r\n    node.style.top = y + \"px\";\r\n    document.body.appendChild(node);\r\n    return node;\r\n  }\r\n\r\n  function remove(node) {\r\n    var p = node && node.parentNode;\r\n    if (p) p.removeChild(node);\r\n  }\r\n\r\n  function fadeOut(tooltip) {\r\n    tooltip.style.opacity = \"0\";\r\n    setTimeout(function() { remove(tooltip); }, 1100);\r\n  }\r\n\r\n  function showError(ts, cm, msg) {\r\n    if (ts.options.showError)\r\n      ts.options.showError(cm, msg);\r\n    else\r\n      tempTooltip(cm, String(msg), ts);\r\n  }\r\n\r\n  function closeArgHints(ts) {\r\n    if (ts.activeArgHints) {\r\n      if (ts.activeArgHints.clear) ts.activeArgHints.clear()\r\n      remove(ts.activeArgHints)\r\n      ts.activeArgHints = null\r\n    }\r\n  }\r\n\r\n  function docValue(ts, doc) {\r\n    var val = doc.doc.getValue();\r\n    if (ts.options.fileFilter) val = ts.options.fileFilter(val, doc.name, doc.doc);\r\n    return val;\r\n  }\r\n\r\n  // Worker wrapper\r\n\r\n  function WorkerServer(ts) {\r\n    var worker = ts.worker = new Worker(ts.options.workerScript);\r\n    worker.postMessage({type: \"init\",\r\n                        defs: ts.options.defs,\r\n                        plugins: ts.options.plugins,\r\n                        scripts: ts.options.workerDeps});\r\n    var msgId = 0, pending = {};\r\n\r\n    function send(data, c) {\r\n      if (c) {\r\n        data.id = ++msgId;\r\n        pending[msgId] = c;\r\n      }\r\n      worker.postMessage(data);\r\n    }\r\n    worker.onmessage = function(e) {\r\n      var data = e.data;\r\n      if (data.type == \"getFile\") {\r\n        getFile(ts, data.name, function(err, text) {\r\n          send({type: \"getFile\", err: String(err), text: text, id: data.id});\r\n        });\r\n      } else if (data.type == \"debug\") {\r\n        window.console.log(data.message);\r\n      } else if (data.id && pending[data.id]) {\r\n        pending[data.id](data.err, data.body);\r\n        delete pending[data.id];\r\n      }\r\n    };\r\n    worker.onerror = function(e) {\r\n      for (var id in pending) pending[id](e);\r\n      pending = {};\r\n    };\r\n\r\n    this.addFile = function(name, text) { send({type: \"add\", name: name, text: text}); };\r\n    this.delFile = function(name) { send({type: \"del\", name: name}); };\r\n    this.request = function(body, c) { send({type: \"req\", body: body}, c); };\r\n  }\r\n});\r\n\ndefine('skylark-widgets-codepad/addons/edit/codemirror',[\r\n    'skylark-langx/langx',\r\n    'skylark-domx-query',\r\n\r\n    'skylark-codemirror/CodeMirror',\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\",\r\n    \"skylark-codemirror/mode/xml/xml\",\r\n    \"skylark-codemirror/mode/css/css\",\r\n    \"skylark-codemirror/mode/javascript/javascript\",\r\n    \"skylark-codemirror/mode/htmlmixed/htmlmixed\",\r\n    \"skylark-codemirror/mode/markdown/markdown\",\r\n\r\n    \"skylark-codemirror/addon/comment/comment\",\r\n\r\n    \"skylark-codemirror/addon/selection/active-line\",\r\n\r\n    \"skylark-codemirror/addon/fold/foldcode\",\r\n    \"skylark-codemirror/addon/fold/foldgutter\",\r\n    \"skylark-codemirror/addon/fold/brace-fold\",\r\n    \"skylark-codemirror/addon/fold/xml-fold\",\r\n    \"skylark-codemirror/addon/fold/indent-fold\",\r\n    \"skylark-codemirror/addon/fold/markdown-fold\",\r\n    \"skylark-codemirror/addon/fold/comment-fold\",\r\n\r\n    \"skylark-codemirror/addon/edit/matchbrackets\",\r\n    \"skylark-codemirror/addon/edit/closebrackets\",\r\n    \"skylark-codemirror/addon/edit/trailingspace\",\r\n\r\n    \"skylark-codemirror/addon/search/searchcursor\",\r\n    \"skylark-codemirror/addon/search/search\",\r\n    \"skylark-codemirror/addon/search/match-highlighter\",\r\n\r\n\r\n    ///\"skylark-codemirror/addon/keymap/emacs\",\r\n    ///\"skylark-codemirror/addon/keymap/sublime\",\r\n\r\n    \"skylark-codemirror/addon/dialog/dialog\",\r\n\r\n    \"skylark-codemirror/addon/hint/anyword-hint\",\r\n    \"skylark-codemirror/addon/hint/javascript-hint\",\r\n\r\n    \"skylark-codemirror/addon/lint/javascript-lint\",\r\n    \"skylark-codemirror/addon/lint/lint\",\r\n\r\n    \"skylark-codemirror/addon/tern/tern\"\r\n], function (langx,$,CodeMirror,Addon,util,CodeGround) {\r\n    'use strict';\r\n    class AddonCodeMirror  extends Addon{\r\n        //constructor(coder, options) \r\n\r\n        get options() {\r\n            return {\r\n                highlightLine: true,\r\n\r\n                lineNumbers: true,\r\n                lineWrapping: true,\r\n                foldGutter: true,\r\n                gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"],\r\n\r\n                pluginCssClass : \"codepad-plugin-codemirror\"\r\n            }\r\n        }\r\n\r\n        _init() {\r\n            super._init();\r\n            var coder = this.coder,\r\n                options = this.options;\r\n\r\n            var priority = 1;\r\n            var i;\r\n            this.editors = {};\r\n            //this.coder = coder;\r\n            var modemap = { 'html': 'htmlmixed' };\r\n            var options = this.options;\r\n            //if (typeof window.CodeMirror === 'undefined') {\r\n            //    return;\r\n            //}\r\n            var $editors = coder.$('.codepad-editor');\r\n            for (i = 0; i < $editors.length; i++) {\r\n                let $textarea = $($editors[i]).find('textarea');\r\n                let type = $textarea.data('codepad-type');\r\n                let editor = this.editors[type] = CodeMirror.fromTextArea($textarea[0], options);\r\n                editor.setOption('mode', util.getMode(type, '', modemap));\r\n                editor.$textarea = $textarea;\r\n                editor.on('change', this.editorChange({\r\n                    type\r\n                }));\r\n\r\n            }\r\n            this.listenTo(coder,\"reseted\",this.update);\r\n        }\r\n\r\n        editorChange(params) {\r\n            return () => {\r\n                var editor = this.editors[params.type];\r\n                editor.$textarea.val(editor.getValue());\r\n                editor.$textarea.trigger(\"change\");\r\n            };\r\n        }\r\n\r\n        update(e) {\r\n            var codes = this.coder.getCodes();\r\n            for (let type in this.editors) {\r\n                let editor = this.editors[type],\r\n                    code = codes[type],\r\n                    content;\r\n                if (langx.isString(code)) {\r\n                    content = code;\r\n                } else {\r\n                    content = code.content || \"\";\r\n                }\r\n                editor.setValue(content);\r\n            }\r\n\r\n        }\r\n\r\n\r\n        static get categoryName() {\r\n            return \"edit\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"codemirror\";\r\n        }        \r\n    };\r\n\r\n    AddonCodeMirror.register(CodeGround);\r\n\r\n    return AddonCodeMirror;\r\n});\ndefine('skylark-widgets-codepad/addons/edit/ace',[\r\n    'skylark-langx/langx',\r\n    'skylark-domx-data',\r\n    'skylark-ace',\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\"\r\n], function (langx,datax,ace,Addon,util,CodeGround) {\r\n    'use strict';\r\n    class AddonAce extends Addon {\r\n        //constructor(coder, options) \r\n\r\n        _init() {\r\n            super._init();\r\n            var coder = this.coder,\r\n                options = this.options;\r\n\r\n            var priority = 1;\r\n            var i;\r\n            this.editors = {};\r\n            //this.coder = coder;\r\n            //options = langx.clone(options);\r\n            //if (typeof //window.ace === 'undefined') {\r\n            //    retur//n;\r\n            // }\r\n            var options = this.options;\r\n\r\n            var $editors = coder.$('.codepad-editor');\r\n            for (i = 0; i < $editors.length; i++) {\r\n                let $textarea = $editors[i].querySelector('textarea');\r\n                let type = datax.data($textarea, 'codepad-type');\r\n                let file = datax.data($textarea, 'codepad-file');\r\n                let $aceContainer = document.createElement('div');\r\n                $editors[i].appendChild($aceContainer);\r\n                let editor = this.editors[type] = ace.edit($aceContainer);\r\n                let editorOptions = langx.clone(options);\r\n                editor.getSession().setMode('ace/mode/' + util.getMode(type, file));\r\n                editor.getSession().setOptions(editorOptions);\r\n                editor.$blockScrolling = Infinity;\r\n\r\n                editor.$textarea = $textarea;\r\n                editor.on('change', this.editorChange({\r\n                    type\r\n                }));\r\n            }\r\n            this.listenTo(coder,\"reseted\",this.update);\r\n            this.update();\r\n        }\r\n        \r\n        editorChange(params) {\r\n            return () => {\r\n                var editor = this.editors[params.type];\r\n                editor.$textarea.val(editor.getValue());\r\n                editor.$textarea.trigger(\"change\");\r\n            };\r\n\r\n            ///return () => {\r\n            ///    var editor = this.editor[params.type];\r\n            ///    params.content = editor.getValue();\r\n            ///    this.coder.emit('change', params);\r\n            ///};\r\n        }\r\n        update(e) {\r\n            var codes = this.coder.getCodes();\r\n            for (let type in this.editors) {\r\n                let editor = this.editors[type],\r\n                    code = codes[type],\r\n                    content;\r\n                if (langx.isString(code)) {\r\n                    content = code;\r\n                } else {\r\n                    content = code.content || \"\";\r\n                }\r\n                editor.getSession().setValue(content);\r\n            }\r\n\r\n            ///var params = e.data,\r\n            ///    editor = this.editor[params.type];\r\n            ///editor.getSession().setValue(params.content);\r\n        }\r\n\r\n\r\n        static get categoryName() {\r\n            return \"edit\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"ace\";\r\n        }        \r\n    };\r\n\r\n    AddonAce.register(CodeGround);\r\n    \r\n    return AddonAce;\r\n});\ndefine('skylark-widgets-codepad/addons/general/console',[\r\n    'skylark-langx/langx',\r\n    \"skylark-domx-styler\",\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\"\r\n], function (langx,styler,Addon,util,CodeGround) {\r\n    'use strict';\r\n    \r\n    class AddonConsole  extends Addon{\r\n        //constructor(coder, options) \r\n\r\n        get options() {\r\n            return {\r\n               autoClear: false \r\n            }\r\n        }\r\n\r\n        _init() {\r\n            super._init();\r\n            var coder = this.coder,\r\n                options = this.options;\r\n            \r\n            var priority = 30;\r\n            var history = [];\r\n            var historyIndex = 0;\r\n            var logCaptureSnippet = `(function ${ this.capture.toString() })();`;\r\n            var contentCache = {\r\n                html: '',\r\n                css: '',\r\n                js: ''\r\n            };\r\n            var $nav = document.createElement('li');\r\n            styler.addClass($nav, 'codepad-nav-item codepad-nav-item-console');\r\n            $nav.innerHTML = '<a href=\"#\" data-codepad-type=\"console\">JS Console</a>';\r\n            var $pane = document.createElement('div');\r\n            styler.addClass($pane, 'codepad-pane codepad-pane-console');\r\n            $pane.innerHTML = `\r\n              <div class=\"codepad-console-container\">\r\n                <ul class=\"codepad-console-output\"></ul>\r\n                <form class=\"codepad-console-input\">\r\n                  <input type=\"text\">\r\n                </form>\r\n              </div>\r\n              <button class=\"codepad-button codepad-console-clear\">Clear</button>\r\n            `;\r\n\r\n            coder._velm.append($pane);\r\n            coder._velm.find('.codepad-nav').append($nav);\r\n            var $container = coder.$container.querySelector('.codepad-console-container');\r\n            var $output = coder.$container.querySelector('.codepad-console-output');\r\n            var $input = coder.$container.querySelector('.codepad-console-input input');\r\n            var $inputForm = coder.$container.querySelector('.codepad-console-input');\r\n            var $clear = coder.$container.querySelector('.codepad-console-clear');\r\n            $inputForm.addEventListener('submit', this.submit.bind(this));\r\n            $input.addEventListener('keydown', this.history.bind(this));\r\n            $clear.addEventListener('click', this.clear.bind(this));\r\n            if (options.autoClear === true) {\r\n                coder.on('change', this.autoClear.bind(this), priority - 1);\r\n            }\r\n            coder.on('change', this.change.bind(this), priority);\r\n            window.addEventListener('message', this.getMessage.bind(this));\r\n            this.$coderContainer = coder.$container;\r\n            this.$container = $container;\r\n            this.$input = $input;\r\n            this.$output = $output;\r\n            this.history = history;\r\n            this.historyIndex = historyIndex;\r\n            this.logCaptureSnippet = logCaptureSnippet;\r\n            this.contentCache = contentCache;\r\n            this.getIframe = this.getIframe.bind(this);\r\n        }\r\n        getIframe() {\r\n            return this.$coderContainer.querySelector('.codepad-pane-result iframe');\r\n        }\r\n        getMessage(e) {\r\n            if (e.source !== this.getIframe().contentWindow) {\r\n                return;\r\n            }\r\n            var data = {};\r\n            try {\r\n                data = JSON.parse(e.data);\r\n            } catch (err) {\r\n            }\r\n            if (data.type === 'codepad-console-log') {\r\n                this.log(data.message);\r\n            }\r\n        }\r\n        autoClear(params, callback) {\r\n            var snippetlessContent = params.content;\r\n            if (params.type === 'js') {\r\n                snippetlessContent = snippetlessContent.replace(this.logCaptureSnippet, '');\r\n            }\r\n            if (params.forceRender === true || this.contentCache[params.type] !== snippetlessContent) {\r\n                this.clear();\r\n            }\r\n            this.contentCache[params.type] = snippetlessContent;\r\n            //callback(null, params);\r\n        }\r\n        change(e) {\r\n            var params = e.data;\r\n            if (params.type !== 'js') {\r\n                return //callback(null, params);\r\n            }\r\n            if (params.content.indexOf(this.logCaptureSnippet) === -1) {\r\n                params.content = `${ this.logCaptureSnippet }${ params.content }`;\r\n            }\r\n            //callback(null, params);\r\n        }\r\n        capture() {\r\n            if (typeof window.console === 'undefined' || typeof window.console.log === 'undefined') {\r\n                window.console = {\r\n                    log: function () {\r\n                    }\r\n                };\r\n            }\r\n            var oldConsoleLog = Function.prototype.bind.call(window.console.log, window.console);\r\n            window.console.log = function () {\r\n                [].slice.call(arguments).forEach(function (message) {\r\n                    window.parent.postMessage(JSON.stringify({\r\n                        type: 'codepad-console-log',\r\n                        message: message\r\n                    }), '*');\r\n                });\r\n                oldConsoleLog.apply(oldConsoleLog, arguments);\r\n            };\r\n        }\r\n        log(message = '', type) {\r\n            var $log = document.createElement('li');\r\n            styler.addClass($log, 'codepad-console-log');\r\n            if (typeof type !== 'undefined') {\r\n                styler.addClass($log, `codepad-console-log-${ type }`);\r\n            }\r\n            $log.innerHTML = message;\r\n            this.$output.appendChild($log);\r\n        }\r\n        submit(e) {\r\n            var inputValue = this.$input.value.trim();\r\n            if (inputValue === '') {\r\n                return e.preventDefault();\r\n            }\r\n            this.history.push(inputValue);\r\n            this.historyIndex = this.history.length;\r\n            this.log(inputValue, 'history');\r\n            if (inputValue.indexOf('return') !== 0) {\r\n                inputValue = 'return ' + inputValue;\r\n            }\r\n            try {\r\n                var scriptOutput = this.getIframe().contentWindow.eval(`(function() {${ inputValue }})()`);\r\n                this.log(scriptOutput);\r\n            } catch (err) {\r\n                this.log(err, 'error');\r\n            }\r\n            this.$input.value = '';\r\n            this.$container.scrollTop = this.$container.scrollHeight;\r\n            e.preventDefault();\r\n        }\r\n        clear() {\r\n            this.$output.innerHTML = '';\r\n        }\r\n        history(e) {\r\n            var UP = 38;\r\n            var DOWN = 40;\r\n            var gotHistory = false;\r\n            var selectionStart = this.$input.selectionStart;\r\n            if (e.keyCode === UP && this.historyIndex !== 0 && selectionStart === 0) {\r\n                this.historyIndex--;\r\n                gotHistory = true;\r\n            }\r\n            if (e.keyCode === DOWN && this.historyIndex !== this.history.length - 1 && selectionStart === this.$input.value.length) {\r\n                this.historyIndex++;\r\n                gotHistory = true;\r\n            }\r\n            if (gotHistory) {\r\n                this.$input.value = this.history[this.historyIndex];\r\n            }\r\n        }\r\n\r\n        static get categoryName() {\r\n            return \"general\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"console\";\r\n        }\r\n        \r\n    };\r\n\r\n    AddonConsole.register(CodeGround);\r\n\r\n    return AddonConsole;\r\n});\ndefine('skylark-widgets-codepad/addons/general/play',[\r\n    'skylark-langx/langx',\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-query\",\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\"\r\n], function (langx,noder,eventer,$,Addon,util,CodeGround) {\r\n    class AddonPlay  extends Addon{\r\n        //constructor(coder, options) \r\n\r\n        get options() {\r\n            return {\r\n               firstRun: true \r\n            }\r\n        }\r\n\r\n        _init() {\r\n            super._init();\r\n\r\n            var coder = this.coder,\r\n                options = this.options;\r\n            \r\n            var priority = 10;\r\n            var cache = {};\r\n            var code = {};\r\n            if (options.firstRun === false) {\r\n                cache = {\r\n                    html: {\r\n                        type: 'html',\r\n                        content: ''\r\n                    },\r\n                    css: {\r\n                        type: 'css',\r\n                        content: ''\r\n                    },\r\n                    js: {\r\n                        type: 'js',\r\n                        content: ''\r\n                    }\r\n                };\r\n            }\r\n            var $button = $('<button/>').prop({\r\n                className : 'codepad-button codepad-button-play',\r\n                innerHTML : 'Run'\r\n            });\r\n\r\n            coder.$().append($button);\r\n\r\n            this.listenTo($button,\"click\",this.run);\r\n\r\n            this.listenTo(coder,\"changed\",this.update);\r\n            \r\n            this.cache = cache;\r\n            this.code = code;\r\n            this.coder = coder;\r\n        }\r\n\r\n        update(e) {\r\n            var params = e.data;\r\n            this.code[params.type] = langx.clone(params);\r\n            if (typeof this.cache[params.type] !== 'undefined') {\r\n                //callback(null, this.cache[params.type]);\r\n                this.cache[params.type].forceRender = null;\r\n            } else {\r\n                this.cache[params.type] = langx.clone(params);\r\n                //callback(null, params);\r\n            }\r\n        }\r\n\r\n        run() {\r\n            this.coder.emit('reseted');\r\n        }\r\n\r\n        static get categoryName() {\r\n            return \"general\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"play\";\r\n        }\r\n\r\n    };\r\n\r\n    AddonPlay.register(CodeGround);\r\n\r\n    return AddonPlay;\r\n});\ndefine('skylark-widgets-codepad/addons/general/pen',[\r\n    'skylark-langx/langx',\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\"\r\n], function (langx,Addon,util,CodeGround) {\r\n    'use strict';\r\n    class AddonPen  extends Addon{\r\n        //constructor(coder, options) \r\n\r\n        _init() {\r\n            super._init();\r\n\r\n            var coder = this.coder,\r\n                options = this.options;\r\n\r\n            let panes = {\r\n                html: {\r\n                    title: 'HTML',\r\n                    classChecker: 'codepad-has-html'\r\n                },\r\n                css: {\r\n                    title: 'CSS',\r\n                    classChecker: 'codepad-has-css'\r\n                },\r\n                js: {\r\n                    title: 'JavaScript',\r\n                    classChecker: 'codepad-has-js'\r\n                },\r\n                console: {\r\n                    title: 'Console',\r\n                    classChecker: 'codepad-plugin-console'\r\n                }\r\n            };\r\n            let $availablePanes = [];\r\n            for (let p in panes) {\r\n                if (coder.$container.classList.contains(panes[p].classChecker)) {\r\n                    $availablePanes.push(coder.$container.querySelector(`.codepad-pane-${ p }`));\r\n                }\r\n            }\r\n            this.resizablePanes = [];\r\n            for (let i = 0; i < $availablePanes.length; i++) {\r\n                let type;\r\n                for (let j = 0; j < $availablePanes[i].classList.length; j++) {\r\n                    if ($availablePanes[i].classList[j].indexOf('codepad-pane-') !== -1) {\r\n                        type = $availablePanes[i].classList[j].replace('codepad-pane-', '');\r\n                        break;\r\n                    }\r\n                }\r\n                if (!type) {\r\n                    continue;\r\n                }\r\n                let $pane = {\r\n                    container: $availablePanes[i],\r\n                    expander: undefined\r\n                };\r\n                this.resizablePanes.push($pane);\r\n                let $paneTitle = document.createElement('div');\r\n                $paneTitle.classList.add('codepad-pane-title');\r\n                $paneTitle.innerHTML = panes[type].title || type;\r\n                let $paneElement = $availablePanes[i].firstElementChild;\r\n                $paneElement.insertBefore($paneTitle, $paneElement.firstChild);\r\n                if (i > 0) {\r\n                    $pane.expander = document.createElement('div');\r\n                    $pane.expander.classList.add('codepad-plugin-pen-expander');\r\n                    $pane.expander.addEventListener('mousedown', this.startExpand.bind(this, coder));\r\n                    $paneElement.insertBefore($pane.expander, $paneTitle);\r\n                }\r\n            }\r\n        }\r\n        startExpand(coder, event) {\r\n            let $pane = this.resizablePanes.filter(pane => {\r\n                return pane.expander === event.target;\r\n            }).shift();\r\n            let $previousPane = this.resizablePanes[this.resizablePanes.indexOf($pane) - 1];\r\n            let $relativePixel = 100 / parseInt(window.getComputedStyle($pane.container.parentNode)['width'], 10);\r\n            $pane.container.parentNode.style.display = 'none';\r\n            $pane.startX = event.clientX;\r\n            $pane.startWidth = parseFloat(window.getComputedStyle($pane.container)['width'], 10);\r\n            $previousPane.startWidth = parseFloat(window.getComputedStyle($previousPane.container)['width'], 10);\r\n            $pane.container.parentNode.style.display = '';\r\n            $pane.mousemove = this.doDrag.bind(this, $pane, $previousPane, $relativePixel);\r\n            $pane.mouseup = this.stopDrag.bind(this, $pane);\r\n            document.addEventListener('mousemove', $pane.mousemove, false);\r\n            document.addEventListener('mouseup', $pane.mouseup, false);\r\n        }\r\n        doDrag(pane, previousPane, relativePixel, event) {\r\n            let ppNewWidth = previousPane.startWidth + (event.clientX - pane.startX) * relativePixel;\r\n            let cpNewWidth = pane.startWidth - (event.clientX - pane.startX) * relativePixel;\r\n            const PANE_MIN_SIZE = 10;\r\n            if (ppNewWidth >= PANE_MIN_SIZE && cpNewWidth >= PANE_MIN_SIZE) {\r\n                pane.container.style.maxWidth = 'none';\r\n                previousPane.container.style.maxWidth = 'none';\r\n                previousPane.container.style.width = `${ ppNewWidth }%`;\r\n                pane.container.style.width = `${ cpNewWidth }%`;\r\n            }\r\n        }\r\n        stopDrag(pane, event) {\r\n            document.removeEventListener('mousemove', pane.mousemove, false);\r\n            document.removeEventListener('mouseup', pane.mouseup, false);\r\n        }\r\n\r\n        static get categoryName() {\r\n            return \"general\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"pen\";\r\n        }\r\n\r\n    };\r\n\r\n    AddonPen.register(CodeGround);\r\n\r\n    return AddonPen;\r\n});\ndefine('skylark-widgets-codepad/addons/general/render',[\r\n    'skylark-langx/langx',\r\n    \"skylark-domx-query\",\r\n    \"../../addon\",\r\n    '../../util',\r\n    \"../../codepad\"\r\n], function (langx,$,Addon,util,CodeGround) {\r\n    'use strict';\r\n    class AddonRender  extends Addon{\r\n        //constructor(coder, options) \r\n\r\n        //default options\r\n        get options () {\r\n            return  {\r\n                html : {\r\n                    template : function (codes) {\r\n                        let style = codes.css || \"\",\r\n                            body = codes.html || \"\", \r\n                            script = codes.js || \"\";\r\n                        return   `\r\n                          <!doctype html>\r\n                          <html>\r\n                            <head>\r\n                              <script>\r\n                                (function () {\r\n                                  window.addEventListener('DOMContentLoaded', function () {\r\n                                    window.parent.postMessage(JSON.stringify({\r\n                                      type: 'codepad-dom-ready'\r\n                                    }), '*')\r\n                                  })\r\n                                }())\r\n                              </script>\r\n\r\n                              <style>${ style }</style>\r\n                            </head>\r\n                            <body>\r\n                              ${ body }\r\n\r\n                              <!--\r\n                                CodeGround:\r\n                                Empty script tag prevents malformed HTML from breaking the next script.\r\n                              -->\r\n                              <script></script>\r\n                              <script>${ script }</script>\r\n                            </body>\r\n                          </html>\r\n                        `;\r\n                    }                    \r\n                }\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        _init() {\r\n            super._init();\r\n\r\n            var coder = this.coder,\r\n                options = this.options;\r\n\r\n\r\n            var supportSrcdoc = !!('srcdoc' in document.createElement('iframe'));\r\n            var $resultFrame = coder.$('.codepad-pane-result iframe');\r\n            var frameContent = '';\r\n            var content = {\r\n                html: '',\r\n                css: '',\r\n                js: ''\r\n            };\r\n            window.addEventListener('message', this.domready.bind(this));\r\n\r\n            this.listenTo(coder,\"changed\",this.update);\r\n\r\n            this.supportSrcdoc = supportSrcdoc;\r\n            this.content = content;\r\n            this.frameContent = frameContent;\r\n            this.$resultFrame = $resultFrame;\r\n            this.callbacks = [];\r\n            this.index = 0;\r\n            this.lastCallback = () => {\r\n            };\r\n            this.update();\r\n        }\r\n\r\n        _render(codes){\r\n          if (!this._renderHtml) {\r\n            let htmlTpl = this.options.html.template;\r\n            if (langx.isString(htmlTpl)) {\r\n              this._renderHtml = langx.template(htmlTpl);\r\n            } else if (langx.isFunction(htmlTpl)) {\r\n              this._renderHtml = htmlTpl;\r\n            }\r\n          }\r\n\r\n          return this._renderHtml(codes);\r\n        }\r\n\r\n        update(e) {\r\n            //var params = e.data;\r\n            //this.content[params.type] = params.content;\r\n            var oldFrameContent = this.frameContent;\r\n            let codes = this.coder.getCodes();\r\n\r\n            this.frameContent = this._render(codes);\r\n            this.lastCallback = () => {\r\n                this.lastCallback = () => {\r\n                };\r\n                //callback(null, params);\r\n            };\r\n            if (this.frameContent === oldFrameContent) {\r\n                //callback(null, params);\r\n                return;\r\n            }\r\n            if (this.supportSrcdoc) {\r\n                var $newResultFrame = document.createElement('iframe');\r\n                this.$resultFrame.replaceWith($newResultFrame);\r\n                this.$resultFrame = $($newResultFrame);\r\n                $newResultFrame.contentWindow.document.open();\r\n                $newResultFrame.contentWindow.document.write(this.frameContent);\r\n                $newResultFrame.contentWindow.document.close();\r\n            } else {\r\n                this.$resultFrame.attr('data-srcdoc', this.frameContent);\r\n                var jsUrl = 'javascript:window.frameElement.getAttribute(\"data-srcdoc\");';\r\n                this.$resultFrame.attr('src', jsUrl);\r\n                if (this.$resultFrame[0].contentWindow) {\r\n                    this.$resultFrame[0].contentWindow.location = jsUrl;\r\n                }\r\n            }\r\n        }\r\n        domready(e) {\r\n            if (e.source !== this.$resultFrame[0].contentWindow) {\r\n                return;\r\n            }\r\n            var data = {};\r\n            try {\r\n                data = JSON.parse(e.data);\r\n            } catch (e) {\r\n            }\r\n            if (data.type === 'codepad-dom-ready') {\r\n                this.lastCallback();\r\n            }\r\n        }\r\n\r\n        static get categoryName() {\r\n            return \"general\";\r\n        }\r\n\r\n        static get addonName(){\r\n            return \"render\";\r\n        }\r\n\r\n    };\r\n\r\n    AddonRender.register(CodeGround);\r\n\r\n    return AddonRender;\r\n});\ndefine('skylark-widgets-codepad/main',[\r\n\t\"./codepad\",\r\n\t\"./addons/edit/codemirror\",\r\n\t\"./addons/edit/ace\",\r\n\t\"./addons/general/console\",\r\n\t\"./addons/general/play\",\r\n\t\"./addons/general/pen\",\r\n\t\"./addons/general/render\"\r\n],function(Codepad){\r\n\r\n\treturn Codepad;\r\n});\ndefine('skylark-widgets-codepad', ['skylark-widgets-codepad/main'], function (main) { return main; });\n\n"]}